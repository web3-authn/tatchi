# Email Recovery `request_id` Tracking

This document specifies how to add a `request_id` to email‑based recovery so the frontend can track verification results (success **and** failure) instead of just polling for a new access key.

The goal is:
- Frontend generates a short `request_id` when it builds the recovery email.
- The subject line encodes `request_id`, `accountId`, and the new public key.
- The `EmailDKIMVerifier` contract stores a `VerificationResult` keyed by `request_id` and exposes a view.
- The frontend polls `get_verification_result(request_id)` until it sees success/failure, then proceeds (or aborts) the recovery flow.

---

## 1. Subject Format & `request_id` Semantics

- New subject format (example):
  - `"recover-123ABC bob.testnet ed25519:HPHNMfHwmBJSqcArYZ5ptTZpukvFoMtuU8TcV2T7mEEy"`
  - `123ABC` is a **6‑character** `request_id`, generated by the frontend.
- Grammar (canonical form):
  - `Subject: recover-<request_id> <accountId> ed25519:<new_public_key>`
  - `request_id`:
    - `[A-Z0-9]{6}` (6 uppercase alphanumeric chars; exact charset can be refined).
    - Uniqueness only needs to hold for the TTL window (e.g. 30–60 minutes).
  - `accountId`: NEAR account id (e.g. `bob.testnet`).
  - `new_public_key`: the deterministic NEAR key derived in the email recovery flow.

---

## 2. Contract Changes – `EmailDKIMVerifier`

### 2.1 Data Model

- Add a struct (or extend the existing one) to capture verification results:

  ```rust
  pub struct VerificationResult {
      pub verified: bool,
      pub account_id: AccountId,
      pub new_public_key: Option<PublicKey>,
      pub error_code: Option<String>,
      pub error_message: Option<String>,
      pub timestamp_ns: u64,
      // Optional: raw or hashed request_id for debugging/auditing.
  }
  ```

- Add persistent storage keyed by `request_id`:

  ```rust
  // Key can be `request_id` or `sha256(request_id)` if we don't
  // want the raw token visible on-chain.
  pub type RequestKey = String; // or [u8; 32] / Vec<u8>

  #[derive(BorshSerialize, BorshDeserialize)]
  pub struct EmailDkimVerifier {
      // ...
      pub verification_results: UnorderedMap<RequestKey, VerificationResult>,
  }
  ```

### 2.2 Recording Results & Scheduled Delete

- In `on_email_verification_onchain_result` and `on_email_verification_private_result`:
  - Compute or receive `request_id`:
    - Either:
      - Extract from the decrypted subject (`recover-<request_id> ...`), or
      - Read from `params.request_id` passed through `EmailEncryptionContext` / outlayer callback payload.
  - Build `VerificationResult`:
    - `verified = true` on success, `false` on any failure.
    - Fill `error_code` / `error_message` for failures (DKIM failure, parsing error, recovery contract failure, etc.).
    - Set `account_id`, `new_public_key` (if known), and `timestamp_ns`.
  - Write into the map:

    ```rust
    self.verification_results.insert(&request_key, &verification);
    ```

- TTL cleanup via yield‑resume:
  - After inserting a result, schedule a future self‑call to clear it:

    ```rust
    fn schedule_clear(&self, request_key: RequestKey) {
        // Use a delayed promise / yield-resume helper
        // to call `clear_verification(request_key)` after N blocks/seconds.
    }
    ```

  - Implement:

    ```rust
    pub fn clear_verification(&mut self, request_key: RequestKey) {
        self.verification_results.remove(&request_key);
    }
    ```

  - TTL target: 30–60 minutes is enough for the client to poll while keeping storage bounded.

### 2.3 View Method

- Add a view for the frontend:

  ```rust
  pub fn get_verification_result(&self, request_id: String) -> Option<VerificationResult> {
      let key = self.request_id_to_key(&request_id); // e.g. hash or identity
      self.verification_results.get(&key)
  }
  ```

- Behavior:
  - `None` → email not yet processed (or TTL expired).
  - `Some(VerificationResult { verified: true, .. })` → success.
  - `Some(VerificationResult { verified: false, .. })` → permanent failure; frontend should surface `error_message` and abort.

---

## 3. Relayer / TEE / ZK‑Email Integration

### 3.1 Binding `request_id` into TEE Context

- `sdk/src/server/email-recovery/teeEmail.ts` already supports arbitrary metadata in `EmailEncryptionContext`.
- Extend the context when calling `encryptEmailForOutlayer` from `EmailRecoveryService`:

  ```ts
  const context: EmailEncryptionContext = {
    account_id: accountId,
    payer_account_id: relayerAccountId,
    network_id: networkId,
    request_id, // new field
  };
  ```

- Outlayer worker:
  - Decrypts the email using the `context`.
  - Passes `request_id` back to `EmailDKIMVerifier` when calling `on_email_verification_*_result` so the contract can store the outcome.

### 3.2 Subject Parsing for Non‑TEE / ZK‑Email Paths

- Update subject parsing in:
  - `sdk/src/server/email-recovery/zkEmail.ts`:
    - `parseAccountIdFromSubject`
    - `parseSubjectBindings`
  - `examples/relay-cloudflare-worker/src/worker-helpers.ts`:
    - `parseAccountIdFromEmailPayload`
- New behavior:
  - Accept both:
    - `recover <accountId> ed25519:<pk>`
    - `recover-<request_id> <accountId> ed25519:<pk>`
  - Optionally expose `request_id` to the relayer for logging and correlation (even if zk-email path doesn’t use `get_verification_result` directly today).

### 3.3 Logging

- Include `request_id` in relayer logs where possible:
  - Email entrypoint (`worker.ts`).
  - `EmailRecoveryService` logs for encrypted and zk-email paths.
  - This makes it easy to correlate:
    - frontend request → email → DKIM verification → on-chain transaction → `get_verification_result`.

---

## 4. Frontend / SDK Changes

All frontend changes should be implemented in the existing `EmailRecoveryFlow` and config types so apps don’t need to handle low‑level polling themselves.

### 4.1 `request_id` Generation & Persistence

- In `sdk/src/core/TatchiPasskey/emailRecovery.ts`:
  - Extend `PendingEmailRecovery`:

    ```ts
    export type PendingEmailRecovery = {
      accountId: AccountId;
      recoveryEmail: string;
      deviceNumber: number;
      nearPublicKey: string;
      requestId: string; // NEW
      // ...
    };
    ```

  - Add a helper to generate `requestId`:

    ```ts
    function generateEmailRecoveryRequestId(): string {
      // e.g. 6 chars from A–Z0–9 using crypto.getRandomValues
    }
    ```

  - When building the pending record in `EmailRecoveryFlow.start`:
    - Generate `requestId` once.
    - Persist it alongside other fields in IndexedDB (via `savePending`).
    - Include it in the SSE `data` payload for step 3 so the UI can display it for debugging if needed.

### 4.2 New Subject Format in `buildMailtoUrlInternal`

- Update `buildMailtoUrlInternal` to include `requestId`:

  ```ts
  const subject = encodeURIComponent(
    `recover-${rec.requestId} ${rec.accountId} ${rec.nearPublicKey}`
  );
  ```

- Keep the body message unchanged (or optionally include the `request_id` there as well for debugging).
- Ensure any unit tests and docs that assert the subject format are updated.

### 4.3 Polling `get_verification_result(request_id)`

- Extend `TatchiPasskeyConfigs` (`sdk/src/core/types/passkeyManager.ts`) under `relayer.emailRecovery`:

  ```ts
  emailRecovery?: {
    minBalanceYocto?: string;
    pollingIntervalMs?: number;
    maxPollingDurationMs?: number;
    pendingTtlMs?: number;
    mailtoAddress?: string;
    dkimVerifierAccountId?: string; // NEW: EmailDKIMVerifier contract id
  };
  ```

- In `EmailRecoveryFlow`:
  - Add a helper to resolve the verifier contract id from config.
  - Replace (or augment) `pollUntilAddKey` with a new loop that:

    1. Calls:
       ```ts
       const result = await nearClient.view<
         { request_id: string },
         VerificationResult | null
       >({
         account: dkimVerifierAccountId,
         method: 'get_verification_result',
         args: { request_id: rec.requestId },
       });
       ```
    2. Interprets the result:
       - `null` → still pending; keep polling.
       - `{ verified: false, ... }` → mark `rec.status = 'error'`, emit an `EmailRecoveryStatus.ERROR` event with `error_message`, stop flow.
       - `{ verified: true, ... }` → proceed to finalization:
         - Optionally cross‑check that `result.account_id` and `result.new_public_key` match `rec.accountId` / `rec.nearPublicKey`.
         - Optionally still call `viewAccessKey` once as a safety check before finalizing.
    3. Uses the existing `pollingIntervalMs` and `maxPollingDurationMs` config knobs.

  - Backwards compatibility:
    - If `dkimVerifierAccountId` is **not** configured or `get_verification_result` fails with a “method not found” error, fall back to the existing `viewAccessKey`‑based polling.

### 4.4 UX Updates

- Frontend / React components that drive the email recovery flow should:
  - Treat “pending” as `get_verification_result` returning `null`.
  - Surface clear error states when `verified === false` and show any `error_message` from the contract.
  - Keep the rest of the flow unchanged:
    - Once verification succeeds, `EmailRecoveryFlow.finalize` still performs registration, local storage, and auto‑login.

---

## 5. Migration & Backwards Compatibility

- Rollout order:
  1. Deploy new `EmailDKIMVerifier` with `verification_results` map, `get_verification_result`, and TTL cleanup.
  2. Update Outlayer / relayer to pass `request_id` into the verification callbacks.
  3. Deploy SDK changes that:
     - Generate and persist `requestId`.
     - Use the new subject format.
     - Poll `get_verification_result` when `dkimVerifierAccountId` is configured.
  4. Update docs and examples to show the new subject format.
- During migration:
  - Clients without `request_id` support keep using the legacy subject and access‑key polling.
  - New clients can rely on `get_verification_result` where the contract supports it.

---

## 6. Implementation TODO

### 6.1 Contract (`EmailDKIMVerifier`)

- [ ] Add `verification_results: UnorderedMap<RequestKey, VerificationResult>` and corresponding `VerificationResult` struct.
- [ ] Plumb `request_id` into `on_email_verification_onchain_result` / `on_email_verification_private_result` (via subject parsing or callback params).
- [ ] On each verification completion, insert a `VerificationResult` keyed by `request_id` (or its hash).
- [ ] Implement `clear_verification(request_key: RequestKey)` and wire a yield‑resume self‑call to delete stale entries after a TTL.
- [ ] Add `get_verification_result(request_id: String) -> Option<VerificationResult>` view.

### 6.2 Relayer / Outlayer / ZK‑Email

- [ ] Extend `EmailEncryptionContext` usage to include `request_id` when calling `encryptEmailForOutlayer`.
- [ ] Ensure the Outlayer worker passes `request_id` back into the `EmailDKIMVerifier` callback payload.
- [ ] Update subject parsing in `sdk/src/server/email-recovery/zkEmail.ts` to support `recover-<request_id> <accountId> ed25519:<pk>` and expose `request_id` where useful.
- [ ] Update `examples/relay-cloudflare-worker/src/worker-helpers.ts` to parse the new subject, returning the same `accountId` as before and optionally logging `request_id`.
- [ ] Add logging of `request_id` throughout the relayer pipeline (email handler, `EmailRecoveryService`, zk-email path).

### 6.3 SDK Frontend (`EmailRecoveryFlow` / configs)

- [ ] Extend `PendingEmailRecovery` with a `requestId: string` field and persist it in IndexedDB.
- [ ] Implement `generateEmailRecoveryRequestId()` and wire it into `EmailRecoveryFlow.start`.
- [ ] Change `buildMailtoUrlInternal` to use the new subject format: `recover-<requestId> <accountId> <nearPublicKey>`.
- [ ] Extend `TatchiPasskeyConfigs.relayer.emailRecovery` with `dkimVerifierAccountId` and read it inside `EmailRecoveryFlow`.
- [ ] Replace or augment `pollUntilAddKey` with a `get_verification_result`‑driven loop, falling back to `viewAccessKey` if the view is unavailable.
- [ ] Update `EmailRecoveryFlow` SSE payloads to include `requestId` where helpful (especially in step 3 / awaiting email).

### 6.4 Docs, Examples, and Tests

- [ ] Update all docs that mention the old subject format:
  - `docs/email-recovery-flow.md`
  - `docs/relayer-encrypted-email-recovery.md`
  - `docs/relayer-zk-email.md`
  - `docs/zk-email-recovery.md`
- [ ] Update examples and fixtures that hard‑code a subject:
  - `sdk/src/__tests__/unit/emailEncryption.test.ts`
  - `sdk/src/__tests__/unit/emailRecoveryService.test.ts`
  - Any `.eml` fixtures under `sdk/src/__tests__/unit/emails/`.
- [ ] Add unit tests for:
  - `generateEmailRecoveryRequestId` (length/charset).
  - Subject parsing with and without `request_id`.
  - `EmailRecoveryFlow` polling behavior when `get_verification_result` returns pending/success/failure.
