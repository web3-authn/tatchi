# Cloudflare Workers WASM Module Loading

## Root Cause: "Invalid URL string." Error

### The Problem

When deploying the relay server to Cloudflare Workers, the VRF (Shamir) WASM module initialization failed with:
```
Error: Invalid URL string.
Status: 500
```

### Why This Happened

**1. `import.meta.url` Doesn't Work in Cloudflare Workers**

The WASM initialization code in `wasm_vrf_worker.js` (generated by wasm-bindgen) uses this pattern:

```javascript
async function __wbg_init(module_or_path) {
    if (typeof module_or_path === 'undefined') {
        // Fallback: construct URL relative to current module
        module_or_path = new URL('wasm_vrf_worker_bg.wasm', import.meta.url);
    }

    if (typeof module_or_path === 'string' || module_or_path instanceof URL) {
        module_or_path = fetch(module_or_path);
    }
    // ... instantiate WASM
}
```

In Cloudflare Workers:
- `import.meta.url` is not a valid HTTP URL
- Constructing `new URL(relativePath, import.meta.url)` produces an invalid URL
- Calling `fetch()` with this invalid URL throws: **"Invalid URL string."**

**2. Module Isolation in Cloudflare Workers Bundler**

Initial attempts to fix this using a global override pattern failed due to module isolation:

```typescript
// This approach didn't work:
import shamirWasmModule from './wasm_vrf_worker_bg.wasm';
configureCloudflareShamirWasm(shamirWasmModule);  // Module-level call

// Later, when shamirWorker.ts initializes:
function ensureWasmInitialized() {
    if (wasmModuleOverride) {  // ❌ This was null!
        // ...
    }
}
```

Cloudflare's bundler creates separate module instances, so the override set in one instance wasn't visible in another.

### Why Signer WASM Worked But VRF WASM Failed

The signer WASM was already configured correctly via `AuthService` config:

```typescript
service = new AuthService({
    signerWasm: {
        moduleOrPath: signerWasmModule,  // ✅ Passed through config
    },
});
```

The VRF/Shamir WASM relied on global state that didn't survive module bundling.

## The Solution

### Pass WASM Module Through Config

Added `moduleOrPath` option to `ShamirConfig` to match the `SignerWasmConfig` pattern:

```typescript
export interface ShamirConfig {
    shamir_p_b64u: string;
    shamir_e_s_b64u: string;
    shamir_d_s_b64u: string;
    // ... other options

    /**
     * Optional override for locating the Shamir VRF WASM module.
     * Required for Cloudflare Workers where import.meta.url doesn't work.
     */
    moduleOrPath?: ShamirWasmModuleSupplier;
}
```

### Updated AuthService Initialization

`AuthService` now sets the WASM override from config before creating `Shamir3PassUtils`:

```typescript
if (!this.shamir3pass && this.config.shamir) {
    // Set WASM module override if provided (for Cloudflare Workers)
    if (this.config.shamir.moduleOrPath) {
        const { setShamirWasmModuleOverride } = await import('./shamirWorker.js');
        setShamirWasmModuleOverride(this.config.shamir.moduleOrPath);
    }

    this.shamir3pass = new Shamir3PassUtils({
        p_b64u: this.config.shamir.shamir_p_b64u,
        e_s_b64u: this.config.shamir.shamir_e_s_b64u,
        d_s_b64u: this.config.shamir.shamir_d_s_b64u,
    });
    await this.shamir3pass.initialize();
}
```

### Cloudflare Worker Configuration

```typescript
import signerWasmModule from '@web3authn/passkey/server/wasm/signer';
import shamirWasmModule from '@web3authn/passkey/server/wasm/vrf';

service = new AuthService({
    // ... other config
    shamir: {
        shamir_p_b64u: env.SHAMIR_P_B64U,
        shamir_e_s_b64u: env.SHAMIR_E_S_B64U,
        shamir_d_s_b64u: env.SHAMIR_D_S_B64U,
        graceShamirKeysFile: '',  // No filesystem in Workers
        moduleOrPath: shamirWasmModule,  // ✅ Pass WASM module
    },
    signerWasm: {
        moduleOrPath: signerWasmModule,
    },
});
```

## Key Takeaways

1. **Never rely on `import.meta.url` in Cloudflare Workers** - it doesn't resolve to valid HTTP URLs
2. **Pass WASM modules explicitly through config** - avoid global state that doesn't survive bundling
3. **Use the same pattern for all WASM modules** - consistency prevents future issues
4. **Add comprehensive logging** - helps diagnose WASM loading issues quickly

## Verification

After the fix, logs confirm successful initialization:

```
[ShamirWasmInit] using override to initialize WASM (type: object)
[ShamirWasmInit] override resolved (WebAssembly.Module)
[ShamirWasmInit] resolved override (type: object, isModule: true)
[ShamirWasmInit] initialized from override successfully
```

HTTP response is now successful:
```
POST /vrf/apply-server-lock
Status: 200 OK
Response: {"kek_cs_b64u":"z4ZNEv6Ztz_3bd6lRod80j14-TGJeIIBkoBQDL4Kof8","keyId":"a8d1fe7c"}
```

