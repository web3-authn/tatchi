# Plan: Make VitePress the Native Homepage (example.localhost)

This plan switches the site root to VitePress and embeds the existing React UI (Navbar, HomePage, Toaster) as Web Components on the VitePress homepage. It also removes React Router from the example app in favor of VitePress routing.

## Target Outcome
- `https://example.localhost/` is served by VitePress (no separate Vite app server at the root).
- The homepage renders the current React UI via a custom element (providers + Navbar + HomePage + Toaster inside Shadow DOM).
- VitePress handles site navigation; React Router is removed from the example app.
- Dev Caddy routes root traffic to VitePress; wallet and relayer hosts remain unchanged.

## Topology
- Dev
  - VitePress: `localhost:5222` (now the site root behind Caddy)
  - Wallet host: `wallet.example.localhost` unchanged
  - Relay server: `relay-server.localhost` unchanged
- Prod build
  - Single static site generated by VitePress. The embedded React code is bundled by VitePress via `vite`.

---

## Step 1 — Promote VitePress to Root
1) Update VitePress config to mount at `/` instead of `/docs/`:
- Edit `examples/vite-secure/src/docs/.vitepress/config.ts:1` and set `base: '/'`.
- Add `vite.envDir` to load `.env.*` from the example app root, so `import.meta.env` works inside React wrappers:

```ts
// examples/vite-secure/src/docs/.vitepress/config.ts
export default defineConfig({
  base: '/',
  // ...
  vite: {
    envDir: fileURLToPath(new URL('../../../', import.meta.url)), // examples/vite-secure
    server: {
      host: 'localhost',
      port: 5222,
      fs: { allow: [appSrc] },
      allowedHosts: ['example.localhost', 'pta-m4.local'],
    },
    resolve: { alias: { '@app': appSrc } },
  },
});
```

2) Adjust theme nav to use VitePress routing only (no SPA back-link hacks). For the root nav, link to `/` and other VitePress pages.

3) Move the docs entry to `/docs/` if desired (optional):
- Keep docs pages under `examples/vite-secure/src/docs/…`.
- Add a docs index under `/docs/` using a page file `examples/vite-secure/src/docs/docs/index.md` and configure sidebar to use `/docs/*` paths (optional, if you want to keep `/docs/` as a section).

---

## Step 2 — Wrap React UI as Web Components
We’ll expose the current React UI as custom elements and mount providers within the shadow root:
- `wallet-app`: full shell (ThemeProvider + PasskeyProvider + ThemeScope) rendering Navbar, HomePage and Toaster.
- Keep the simple `wallet-navbar` wrapper if you still want standalone usage elsewhere (already exists at `examples/vite-secure/src/components/registerNavbarWC.tsx`).

1) Add `registerAppShellWC.tsx`:
```tsx
// examples/vite-secure/src/components/registerAppShellWC.tsx
import React from 'react';
import { createRoot, type Root } from 'react-dom/client';
import { PasskeyProvider, ThemeProvider, ThemeScope } from '@tatchi/sdk/react';
import '@tatchi/sdk/react/styles';

import { Navbar } from './Navbar';
import { HomePage } from '../pages/HomePage';
import { ToasterThemed } from './ToasterThemed';

// Inline app stylesheet inside shadow root
// Vite will load the file contents as a string with ?raw
// eslint-disable-next-line
// @ts-ignore
import appCss from '../index.css?raw';

class WalletAppElement extends HTMLElement {
  private root: Root | null = null;
  private shadow: ShadowRoot | null = null;

  connectedCallback() {
    if (this.shadow) return;
    this.shadow = this.attachShadow({ mode: 'open' });

    // Inject styles for app classes
    const styleTag = document.createElement('style');
    styleTag.textContent = appCss as string;
    this.shadow.appendChild(styleTag);

    const container = document.createElement('div');
    this.shadow.appendChild(container);

    const env = import.meta.env;

    this.root = createRoot(container);
    this.root.render(
      <ThemeProvider>
        <PasskeyProvider
          config={{
            relayer: {
              url: env.VITE_RELAYER_URL!,
              accountId: env.VITE_RELAYER_ACCOUNT_ID!,
            },
            vrfWorkerConfigs: {
              shamir3pass: {
                relayServerUrl: env.VITE_RELAYER_URL!,
              }
            },
            iframeWallet: {
              walletOrigin: env.VITE_WALLET_ORIGIN,
              walletServicePath: env.VITE_WALLET_SERVICE_PATH,
              rpIdOverride: env.VITE_RP_ID_BASE,
              sdkBasePath: env.VITE_SDK_BASE_PATH,
              enableSafariGetWebauthnRegistrationFallback: true,
            },
          }}
        >
          <ThemeScope as="div" className="app-theme-scope">
            <Navbar />
            <main>
              <HomePage />
            </main>
            <ToasterThemed />
          </ThemeScope>
        </PasskeyProvider>
      </ThemeProvider>
    );
  }

  disconnectedCallback() {
    try { this.root?.unmount(); } finally { this.root = null; }
  }
}

if (!customElements.get('wallet-app')) {
  customElements.define('wallet-app', WalletAppElement);
}
```

Notes:
- The wrapper uses `index.css?raw` to inject app styles inside the Shadow DOM so navbar/homepage look correct.
- `envDir` in Step 1 ensures `import.meta.env.VITE_*` resolves while building within VitePress.

2) Register the element from the VitePress theme on the client:
```ts
// examples/vite-secure/src/docs/.vitepress/theme/index.ts
import DefaultTheme from 'vitepress/theme';
import type { Theme } from 'vitepress';

const theme: Theme = {
  ...DefaultTheme,
  enhanceApp: async (ctx) => {
    // @ts-ignore optional upstream hook
    await (DefaultTheme as any).enhanceApp?.(ctx);
    if (import.meta.env.SSR) return;

    await import('@tatchi/sdk/react/styles');

    if (!customElements.get('wallet-app')) {
      await import('@app/components/registerAppShellWC');
    }
  },
};
export default theme;
```

Optional — AppShell single import (no side effects)
If you prefer VitePress to import a single, side‑effect‑free module instead of a purpose‑built wrapper, extract your app into an AppShell and a small mount helper.

1) Create an App component (no ReactDOM, no Router):
```tsx
// examples/tatchi-docs/src/App.tsx
import React from 'react'
import { PasskeyProvider, ThemeProvider, ThemeScope } from '@tatchi/sdk/react'
import '@tatchi/sdk/react/styles'
import NavbarStatic from './components/NavbarStatic'
import { HomePage } from './pages/HomePage'
import { ToasterThemed } from './components/ToasterThemed'

function buildConfig(env: ImportMetaEnv) {
  return {
    relayer: { url: env.VITE_RELAYER_URL!, accountId: env.VITE_RELAYER_ACCOUNT_ID! },
    vrfWorkerConfigs: { shamir3pass: { relayServerUrl: env.VITE_RELAYER_URL! } },
    iframeWallet: {
      walletOrigin: env.VITE_WALLET_ORIGIN,
      walletServicePath: env.VITE_WALLET_SERVICE_PATH,
      rpIdOverride: env.VITE_RP_ID_BASE,
      sdkBasePath: env.VITE_SDK_BASE_PATH,
      enableSafariGetWebauthnRegistrationFallback: true,
    },
  }
}

export const App: React.FC = () => {
  const env = import.meta.env
  const config = buildConfig(env)
  return (
    <ThemeProvider>
      <PasskeyProvider config={config}>
        <ThemeScope as="div" className="app-theme-scope">
          <NavbarStatic />
          <main>
            <HomePage />
          </main>
          <ToasterThemed />
        </ThemeScope>
      </PasskeyProvider>
    </ThemeProvider>
  )
}
```

2) Add a small mount helper you can reuse in SPA dev and WC:
```tsx
// examples/tatchi-docs/src/mount.tsx
import React from 'react'
import { createRoot } from 'react-dom/client'
import { App } from './App'

export function mountApp(container: Element) {
  const root = createRoot(container)
  root.render(<App />)
  return () => root.unmount()
}
```

3) Update the SPA entry to use `mountApp` (optional, keeps local dev standalone):
```tsx
// examples/tatchi-docs/src/main.tsx
import { mountApp } from './mount'

const el = document.getElementById('app-root')
if (el) mountApp(el)
```

4) Make the Web Component minimal by importing the AppShell:
```tsx
// examples/tatchi-docs/src/components/registerAppShellWC.tsx
import React from 'react'
import { createRoot } from 'react-dom/client'
import { App } from '../App'
// eslint-disable-next-line
// @ts-ignore
import appCss from '../index.css?raw'

class WalletAppElement extends HTMLElement {
  private root: ReturnType<typeof createRoot> | null = null
  connectedCallback() {
    const shadow = this.attachShadow({ mode: 'open' })
    const style = document.createElement('style')
    style.textContent = appCss as string
    shadow.appendChild(style)
    const host = document.createElement('div')
    shadow.appendChild(host)
    this.root = createRoot(host)
    this.root.render(<App />)
  }
  disconnectedCallback() { try { this.root?.unmount() } finally { this.root = null } }
}
if (!customElements.get('wallet-app')) customElements.define('wallet-app', WalletAppElement)
```

Why this helps
- One import: VitePress only loads `registerAppShellWC` (or `App`) without pulling in a router or bootstrap side effects.
- Reuse: `mountApp` keeps SPA dev working if you still run the app standalone.
- Env: `import.meta.env` continues to work when bundling via VitePress because of `vite.envDir`.

## Env Vars in VitePress (import.meta.env)
- Source of vars
  - VitePress is powered by Vite; client-exposed vars come from `.env*` files located under `vite.envDir` (Step 1) and from the shell environment.
  - Only variables prefixed with `VITE_` are exposed to browser code. Keep secrets out of client bundles.

- Usage pattern
  - Always access exactly via `import.meta.env` (no optional chaining). Example:
    ```ts
    const env = import.meta.env
    const relayerUrl = env.VITE_RELAYER_URL!
    ```
  - Place reads inside client-only code paths. The web component wrapper is only imported on the client (`if (import.meta.env.SSR) return` guard in theme), which is safe for SSR.

- Where values land
  - In dev, Vite injects values at runtime; in build, they are statically replaced during bundling.
  - Changing `.env` requires restarting the VitePress dev server.

- Paths and base
  - Use `import.meta.env.BASE_URL` for the docs base when creating links within VitePress (e.g., pointing the “SDK” nav to the docs root regardless of `/` vs `/docs/`).
  - For links back to the app root, prefer `window.location.origin` or an explicit `VITE_APP_PUBLIC_ORIGIN` override rather than hardcoding hosts.

---

## Step 3 — VitePress Homepage Uses the Web Component
Create a homepage that mounts the shell inside a client-only block.

```md
<!-- examples/vite-secure/src/docs/index.md -->
---
layout: home
hero:
  name: Tatchi
  text: Passkey SDK and examples
  tagline: Web3Authn, Wallet Iframe, Device Linking
---

<script setup>
import { ClientOnly } from 'vitepress';
</script>

<ClientOnly>
  <wallet-app />
</ClientOnly>
```

You can keep docs under `/docs/*` by adding a section index and nav entries, or keep all content at the root depending on preference. If you want a Demos page, create `examples/vite-secure/src/docs/demos/index.md` and link to `/demos/` from the navbar.

---

## Step 4 — Remove React Router in the Example App
We’ll align the in-app UI to VitePress routing, avoiding `react-router-dom`.

1) Update Navbar to use ordinary anchors and `window.location` for programmatic navigation:
```tsx
// examples/vite-secure/src/components/Navbar.tsx
import React from 'react';
import toast from 'react-hot-toast';
import { usePasskeyContext, ProfileSettingsButton, DeviceLinkingPhase, DeviceLinkingStatus, ThemeScope, useTheme } from '@tatchi/sdk/react';

export const Navbar: React.FC = () => {
  const { loginState } = usePasskeyContext();
  const { setTheme } = useTheme();
  // ... keep the rest
  return (
    <ThemeScope>
      <nav className="navbar-container">
        <div className="navbar-title">
          <a href="/">Tatchi.xyz</a>
        </div>
        <div className="navbar-links">
          <a href="/">Home</a>
          <a href="/demos/">Demos</a>
          <a href="/docs/" rel="external">Docs</a>
        </div>
        {/* ProfileSettingsButton with onLogout={() => (window.location.href = '/')} */}
      </nav>
    </ThemeScope>
  );
};
```

2) Remove Router from the app entry or stop using it for the homepage. Since VitePress is the host now, `examples/vite-secure/src/main.tsx` is no longer the primary entry. You can keep it for isolated Vite app dev or delete/trim it later.

3) Drop the dependency:
- Remove `react-router-dom` from `examples/vite-secure/package.json`.

---

## Step 5 — Dev Routing (Caddy) and Scripts
1) Point `example.localhost` to VitePress dev server by replacing the current site block with:
```caddy
example.localhost {
  tls internal
  encode gzip
  handle { reverse_proxy localhost:5222 }
}
```

2) Keep wallet and relayer hosts intact.

3) Add scripts in the workspace `package.json` (or reuse existing):
```json
{
  "scripts": {
    "site:dev": "vitepress dev examples/vite-secure/src/docs --port 5222",
    "site:build": "vitepress build examples/vite-secure/src/docs",
    "site:preview": "vitepress preview examples/vite-secure/src/docs --port 5222"
  }
}
```

---

## Step 6 — Build & Deploy
- `pnpm site:build` generates the static site.
- Publish the VitePress output directory (default `.vitepress/dist` under the site root). If you want the build to land under `examples/vite-secure/dist`, configure `--outDir examples/vite-secure/dist` or set `build.outDir` in VitePress config.
- Ensure any server that previously served the Vite app is updated to serve the VitePress build instead.

---

## Testing & Pitfalls
- Shadow DOM CSS: we inject `index.css` into the custom element using `?raw`; if you add new app styles, they also need to be imported (or compose a dedicated `app-shell.css`).
- CSS URLs/imports: `?raw` bypasses Vite’s CSS processing. Avoid `url(...)` and `@import` in the injected CSS, or pre-resolve assets. Prefer a minimal `app-shell.css` that doesn’t rely on asset URL rewriting.
- Dev HMR for CSS: to live-update injected CSS in dev, accept HMR for the `?raw` module and update the style tag:
  ```ts
  // inside connectedCallback after creating styleTag
  if (import.meta.hot) {
    import.meta.hot.accept('../index.css?raw', (mod: any) => {
      styleTag.textContent = mod?.default ?? ''
    })
  }
  ```
- Tokens/styles: `@tatchi/sdk/react/styles` is imported within the wrapper; confirm components read tokens via `ThemeProvider/ThemeScope` correctly in Shadow DOM.
- Env vars: set `vite.envDir` so `VITE_*` variables resolve during VitePress build.
- SSR/Client-only: register custom elements only on the client (`import.meta.env.SSR` guards). Use `<ClientOnly>` for the homepage mount.
- Toaster mounting: `react-hot-toast` renders into `document.body` by default; this is acceptable, but if you want it fully contained within the element, pass a custom `container` or `containerStyle`.
- Router remnants: after removing React Router, replace `Link`/`useNavigate` with anchors/`window.location` as shown.
- Dedupe React: if VitePress and the app pull different React copies, add `resolve: { dedupe: ['react','react-dom'] }` in VitePress `vite` config to avoid hooks/context mismatches.
- FS allowlist: when importing from outside the docs folder via `@app`, keep `server.fs.allow` including the app path; otherwise Vite will block file access.

---

## Checklist
- [ ] `base: '/'` and `vite.envDir` set in VitePress config
- [ ] `registerAppShellWC.tsx` created and registered from theme
- [ ] Homepage mounts `<wallet-app />` inside `<ClientOnly>`
- [ ] Caddy root proxies to VitePress (:5222)
- [ ] Navbar refactored to anchor-based nav; React Router removed
- [ ] Build and preview the site from VitePress
