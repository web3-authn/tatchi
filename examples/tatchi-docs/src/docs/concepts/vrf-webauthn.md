---
title: VRF Webauthn
---


# VRF Webauthn

The Web3Authn contract uses **verifiable random function (VRF)* based challeges, enabling stateless and serverless Webauthn authentication with an onchain contract, instead of requiring a server.

Traditionally, a webauthn server would need be required. The client would request the challenge, sign it as part of the webauthn authentication and return the payload to the server in order to prevent replay attacks and ensure user presence.

Instead, we use VRFs to generate the webauthn challenge client-side, bind fresh blockchain data to ensure freshness and prevent replay attacks in the challenge, and verify both the VRF output matches the VRF public key stored onchain, and the webauthn authentication.


## VRF Challenge Construction

Challenges bind fresh blockchain data with user identity:

| Field | Purpose | Source |
|-------|---------|--------|
| `domain_separator` | Prevents cross-protocol collisions | Fixed constant (`"web3_authn_challenge_v3"`) |
| `user_id` | Binds challenge to user identity | Client session |
| `relying_party_id` | Binds to origin (e.g., `"example.com"`) | Client config |
| `block_height` | Ensures freshness and replay protection | NEAR RPC |
| `block_hash` | Prevents reuse across forks/reorgs | NEAR RPC |

**VRF security properties:**
- Unpredictable outputs (indistinguishable from random)
- Verifiable proofs (anyone can verify with public key)
- Deterministic (same input → same output)
- Non-malleable (requires private key to forge)
- Block-bound freshness (challenges expire with old blocks)
- Account-bound (VRF public keys tied to NEAR accounts)

Together, these enable:

- Deterministic key derivation bound to origins
- Fresh, verifiable challenges tied to blockchain state
- Session-like UX without sacrificing security


## WebAuthn PRF: Deriving NEAR keys

The wallet combines PRF output with an account-specific salt:

```
PRF output + account salt → NEAR keypair (deterministic)
```

This makes key derivation:

- Deterministic for a given account + credential
- Different across accounts (via the salt)
- Bound to the origin (via the `rpId`)

**Encrypting keys at rest:**

PRF output is fed into a key derivation function (like HKDF):

```
PRF output → KDF → encryption keys
```

These keys encrypt private keys before storing them in IndexedDB.

**Security properties:**

- PRF output never leaves the wallet origin
- Your app never sees it
- Relay servers never see it
- It's only available via WebAuthn ceremonies

**Key takeaway:** PRF gives us deterministic, origin-bound key material without managing passwords or separate key storage.


## VRF-backed WebAuthn challenges

### Challenge input components

| Field | Purpose |
|-------|---------|
| **Domain separator** | Prevents cross-protocol reuse |
| **User ID** | Binds challenge to a specific user |
| **Session ID** | Keeps challenges unique per browser session |
| **Relying party ID** | Pins challenge to expected origin |
| **Block height + hash** | Provides freshness and fork protection |
| **Timestamp** | Supports audit logs and expiry logic |

All fields are concatenated and hashed before being passed to the VRF.

### Flow in detail

**1. Build the input**

```ts
const input = concat(
  DOMAIN_SEPARATOR,
  userId,
  sessionId,
  rpId,
  blockHeight,
  blockHash,
  timestamp
)
const inputHash = sha256(input)
```

**2. Generate VRF output and proof**

```ts
const { output, proof } = vrfWorker.evaluate(inputHash)
```

**3. Use output as WebAuthn challenge**

```ts
const credential = await navigator.credentials.create({
  publicKey: {
    challenge: output,  // VRF output
    // ... other options
  }
})
```

**4. Send proof to contract**

When submitting the transaction:

```ts
contract.verify_and_execute({
  vrf_input: input,
  vrf_proof: proof,
  webauthn_response: credential.response,
  // ...
})
```

**5. Contract verification**

```ts
contract.verify_and_execute({
  vrf_input: input,
  vrf_proof: proof,
  webauthn_response: credential.response,
  // ...
})
```

## Web3Authn Contract Verification

The Web3Authn contract performs atomic verification of both VRF proofs and WebAuthn signatures before executing any transaction.

### What the Contract Verifies

**1. VRF Proof Verification**
- Verifies the VRF proof against the user's VRF public key stored on-chain
- Computes the VRF output from the proof and input
- Ensures the proof was generated by the correct private key

**2. WebAuthn P256 Signature Verification**
- Verifies the ECDSA P256 signature in the WebAuthn response
- Validates against the passkey's public key stored on-chain
- Confirms the signature covers the VRF output (used as challenge)

**3. Challenge Binding**
- Ensures the WebAuthn challenge equals the VRF output
- This binds the WebAuthn authentication to the VRF-generated challenge
- Prevents challenge substitution attacks

**4. Freshness Check**
- Validates the block height in the VRF input is recent (within MAX_AGE blocks)
- Prevents replay attacks using old challenges

```rust
// Simplified contract logic
fn verify_and_execute(input, proof, webauthn_response) {
    // 1. Verify VRF proof → extract output
    let vrf_output = vrf_verify(user_vrf_pubkey, input, proof)?;

    // 2. Check freshness
    assert!(input.block_height >= env::block_height() - MAX_AGE);

    // 3. Verify WebAuthn signature with VRF output as challenge
    verify_webauthn_signature(
        passkey_pubkey,
        webauthn_response,
        vrf_output  // Challenge must match VRF output
    )?;

    // 4. Execute transaction
    execute(...);
}
```

**Security guarantees:**
- **Dual verification**: Both VRF and WebAuthn must pass atomically
- **Challenge binding**: VRF output cryptographically linked to WebAuthn response
- **Freshness**: Block-bound challenges prevent replay attacks
- **On-chain state**: Public keys stored immutably on-chain
- **No server required**: All verification happens on-chain


## How It All Works Together

The wallet combines three cryptographic primitives:

**WebAuthn PRF** → Origin-bound key derivation
- Derives deterministic NEAR keys from passkey
- Encrypts VRF keypair for storage
- Bound to wallet origin, never exposed to apps

**VRF** → Verifiable, blockchain-aware challenges
- Generates unpredictable WebAuthn challenges
- Binds fresh block data for replay protection
- Verifiable on-chain without server state

**Shamir 3-Pass** → Frictionless session unlock
- Optional unlock without biometric prompts
- Falls back to PRF if unavailable
- Reduces friction without compromising security

**Result:** Cryptographic guarantees without passwords, server state, or trusted oracles.

## Next steps

- Explore the [Shamir 3-pass protocol](../guides/shamir-3-pass-protocol) for smoother login UX
- Learn how the [nonce manager](../guides/nonce-manager.md) prevents transaction replay
- Review [credential scope strategies](credential-scope-rpid)
