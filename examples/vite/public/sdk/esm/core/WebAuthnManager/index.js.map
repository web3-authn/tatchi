{"version":3,"file":"index.js","names":["UserPreferencesInstance","NonceManagerInstance","result: {\n        success: boolean;\n        vrfPublicKey: string;\n        encryptedVrfKeypair: EncryptedVRFKeypair;\n        vrfChallenge: VRFChallenge | null;\n        serverEncryptedVrfKeypair: ServerEncryptedVrfKeypair | null;\n      }","error: any"],"sources":["../../../../src/core/WebAuthnManager/index.ts"],"sourcesContent":["import {\n  IndexedDBManager,\n  type ClientUserData,\n  type ClientAuthenticatorData,\n} from '../IndexedDBManager';\nimport { PasskeyClientDBManager, StoreUserDataInput, UserPreferences } from '../IndexedDBManager/passkeyClientDB';\nimport { type NearClient, SignedTransaction } from '../NearClient';\nimport { SignerWorkerManager } from './SignerWorkerManager';\nimport { VrfWorkerManager } from './VrfWorkerManager';\nimport { TouchIdPrompt } from './touchIdPrompt';\nimport { base64UrlEncode } from '../../utils/encoders';\nimport { toAccountId } from '../types/accountIds';\nimport { UserPreferencesManager } from './userPreferences';\nimport UserPreferencesInstance from './userPreferences';\nimport { NonceManager } from '../nonceManager';\nimport NonceManagerInstance from '../nonceManager';\n\n\nimport {\n  EncryptedVRFKeypair,\n  ServerEncryptedVrfKeypair,\n  VRFInputData,\n  VRFChallenge\n} from '../types/vrf-worker';\nimport type { ActionArgsWasm, TransactionInputWasm } from '../types/actions';\nimport type { PasskeyManagerConfigs, onProgressEvents } from '../types/passkeyManager';\nimport type { VerifyAndSignTransactionResult } from '../types/passkeyManager';\nimport type { AccountId } from '../types/accountIds';\nimport type { AuthenticatorOptions } from '../types/authenticatorOptions';\nimport type { ConfirmationConfig, RpcCallPayload } from '../types/signer-worker';\n\n\n/**\n * WebAuthnManager - Main orchestrator for WebAuthn operations\n *\n * Architecture:\n * - index.ts (this file): Main class orchestrating everything\n * - signerWorkerManager: NEAR transaction signing, and VRF Web3Authn verification RPC calls\n * - vrfWorkerManager: VRF keypair generation, challenge generation\n * - touchIdPrompt: TouchID prompt for biometric authentication\n */\nexport class WebAuthnManager {\n  private readonly vrfWorkerManager: VrfWorkerManager;\n  private readonly signerWorkerManager: SignerWorkerManager;\n  private readonly touchIdPrompt: TouchIdPrompt;\n  private readonly userPreferencesManager: UserPreferencesManager;\n  private readonly nonceManager: NonceManager;\n\n  readonly passkeyManagerConfigs: PasskeyManagerConfigs;\n\n  /**\n   * Public getter for NonceManager instance\n   */\n  getNonceManager(): NonceManager {\n    return this.nonceManager;\n  }\n\n  constructor(\n    passkeyManagerConfigs: PasskeyManagerConfigs,\n    nearClient: NearClient\n  ) {\n    const { vrfWorkerConfigs } = passkeyManagerConfigs;\n    // Group VRF worker configuration into a single object\n    this.vrfWorkerManager = new VrfWorkerManager({\n      shamirPB64u: vrfWorkerConfigs?.shamir3pass?.p,\n      relayServerUrl: vrfWorkerConfigs?.shamir3pass?.relayServerUrl,\n      applyServerLockRoute: vrfWorkerConfigs?.shamir3pass?.applyServerLockRoute,\n      removeServerLockRoute: vrfWorkerConfigs?.shamir3pass?.removeServerLockRoute,\n    });\n    this.touchIdPrompt = new TouchIdPrompt();\n    this.userPreferencesManager = UserPreferencesInstance;\n    this.nonceManager = NonceManagerInstance;\n    this.signerWorkerManager = new SignerWorkerManager(\n      this.vrfWorkerManager,\n      nearClient,\n      UserPreferencesInstance,\n      NonceManagerInstance\n    );\n    this.passkeyManagerConfigs = passkeyManagerConfigs;\n    // VRF worker initializes on-demand with proper error propagation\n  }\n\n  /**\n   * Public pre-warm hook to initialize signer workers ahead of time.\n   * Safe to call multiple times; errors are non-fatal.\n   */\n  prewarmSignerWorkers(): void {\n    try {\n      if (typeof window !== 'undefined' && typeof (window as any).Worker !== 'undefined') {\n        this.signerWorkerManager.preWarmWorkerPool().catch(() => {});\n      }\n    } catch {}\n  }\n\n  getCredentials({ nearAccountId, challenge, authenticators }: {\n    nearAccountId: AccountId;\n    challenge: VRFChallenge;\n    authenticators: ClientAuthenticatorData[];\n  }): Promise<PublicKeyCredential> {\n    return this.touchIdPrompt.getCredentials({ nearAccountId, challenge, authenticators });\n  }\n\n  ///////////////////////////////////////\n  // VRF MANAGER FUNCTIONS\n  ///////////////////////////////////////\n\n  async generateVrfChallenge(vrfInputData: VRFInputData): Promise<VRFChallenge> {\n    return this.vrfWorkerManager.generateVrfChallenge(vrfInputData);\n  }\n\n  /**\n   * Generate VRF keypair for bootstrapping - stores in memory unencrypted temporarily\n   * This is used during registration to generate a VRF keypair that will be used for\n   * WebAuthn ceremony and later encrypted with the real PRF output\n   *\n   * @param saveInMemory - Whether to persist the generated VRF keypair in WASM worker memory\n   * @param vrfInputParams - Optional parameters to generate VRF challenge/proof in same call\n   * @returns VRF public key and optionally VRF challenge data\n   */\n  async generateVrfKeypairBootstrap(\n    saveInMemory: boolean,\n    vrfInputData: VRFInputData\n  ): Promise<{\n    vrfPublicKey: string;\n    vrfChallenge: VRFChallenge;\n  }> {\n    return this.vrfWorkerManager.generateVrfKeypairBootstrap(vrfInputData, saveInMemory);\n  }\n\n  /**\n   * Derive deterministic VRF keypair from PRF output for recovery\n   * Optionally generates VRF challenge if input parameters are provided\n   * This enables deterministic VRF key derivation from WebAuthn credentials\n   *\n   * @param credential - WebAuthn credential containing PRF outputs\n   * @param nearAccountId - NEAR account ID for key derivation salt\n   * @param vrfInputParams - Optional VRF inputs, if provided will generate a challenge\n   * @param saveInMemory - Whether to save the derived VRF keypair in worker memory for immediate use\n   * @returns Deterministic VRF public key, optional VRF challenge, and encrypted VRF keypair for storage\n   */\n  async deriveVrfKeypair({\n    credential,\n    nearAccountId,\n    vrfInputData,\n    saveInMemory = true,\n  }: {\n    credential: PublicKeyCredential;\n    nearAccountId: AccountId;\n    vrfInputData?: VRFInputData; // optional, for challenge generation\n    saveInMemory?: boolean; // optional, whether to save in worker memory\n  }): Promise<{\n    success: boolean;\n    vrfPublicKey: string;\n    encryptedVrfKeypair: EncryptedVRFKeypair;\n    vrfChallenge: VRFChallenge | null;\n    serverEncryptedVrfKeypair: ServerEncryptedVrfKeypair | null;\n  }> {\n    try {\n      console.debug('WebAuthnManager: Deriving deterministic VRF keypair from PRF output');\n      const vrfResult = await this.vrfWorkerManager.deriveVrfKeypairFromPrf({\n        credential,\n        nearAccountId,\n        vrfInputData,\n        saveInMemory,\n      });\n\n      console.debug(`Derived VRF public key: ${vrfResult.vrfPublicKey}`);\n      if (vrfResult.vrfChallenge) {\n        console.debug(`Generated VRF challenge with output: ${vrfResult.vrfChallenge.vrfOutput.substring(0, 20)}...`);\n      } else {\n        console.debug('No VRF challenge generated (vrfInputData not provided)');\n      }\n      if (vrfResult.encryptedVrfKeypair) {\n        console.debug(`Generated encrypted VRF keypair for storage`);\n      }\n      console.debug('WebAuthnManager: Deterministic VRF keypair derived successfully');\n\n      const result: {\n        success: boolean;\n        vrfPublicKey: string;\n        encryptedVrfKeypair: EncryptedVRFKeypair;\n        vrfChallenge: VRFChallenge | null;\n        serverEncryptedVrfKeypair: ServerEncryptedVrfKeypair | null;\n      } = {\n        success: true,\n        vrfPublicKey: vrfResult.vrfPublicKey,\n        encryptedVrfKeypair: vrfResult.encryptedVrfKeypair,\n        vrfChallenge: vrfResult.vrfChallenge,\n        serverEncryptedVrfKeypair: vrfResult.serverEncryptedVrfKeypair,\n      };\n\n      return result;\n\n    } catch (error: any) {\n      console.error('WebAuthnManager: VRF keypair derivation error:', error);\n      throw new Error(`VRF keypair derivation failed ${error.message}`);\n    }\n  }\n\n  /**\n   * Unlock VRF keypair in memory using PRF output\n   * This is called during login to decrypt and load the VRF keypair in-memory\n   */\n  async unlockVRFKeypair({\n    nearAccountId,\n    encryptedVrfKeypair,\n    credential,\n  }: {\n    nearAccountId: AccountId;\n    encryptedVrfKeypair: EncryptedVRFKeypair;\n    credential: PublicKeyCredential;\n  }): Promise<{ success: boolean; error?: string }> {\n    try {\n      console.debug('WebAuthnManager: Unlocking VRF keypair');\n\n      const unlockResult = await this.vrfWorkerManager.unlockVrfKeypair({\n        credential,\n        nearAccountId,\n        encryptedVrfKeypair,\n      });\n\n      if (!unlockResult.success) {\n        console.error('WebAuthnManager: VRF keypair unlock failed');\n        return { success: false, error: 'VRF keypair unlock failed' };\n      }\n\n      // Warm up signer workers after a successful unlock to minimize first-use latency\n      try { this.signerWorkerManager.preWarmWorkerPool().catch(() => {}); } catch {}\n\n      return { success: true };\n\n    } catch (error: any) {\n      console.error('WebAuthnManager: VRF keypair unlock failed:', error.message);\n      return { success: false, error: error.message };\n    }\n  }\n\n  /**\n   * Perform Shamir 3-pass commutative decryption within WASM worker\n   * This securely decrypts a server-encrypted KEK (key encryption key)\n   * which the wasm worker uses to unlock a key to decrypt the VRF keypair and loads it into memory\n   * The server never knows the real value of the KEK, nor the VRF keypair\n   */\n  async shamir3PassDecryptVrfKeypair({\n    nearAccountId,\n    kek_s_b64u,\n    ciphertextVrfB64u,\n  }: {\n    nearAccountId: AccountId;\n    kek_s_b64u: string;\n    ciphertextVrfB64u: string;\n  }): Promise<{ success: boolean; error?: string }> {\n    const result = await this.vrfWorkerManager.shamir3PassDecryptVrfKeypair({\n      nearAccountId,\n      kek_s_b64u,\n      ciphertextVrfB64u,\n    });\n\n    return {\n      success: result.success,\n      error: result.error\n    };\n  }\n\n  async clearVrfSession(): Promise<void> {\n    return await this.vrfWorkerManager.clearVrfSession();\n  }\n\n  /**\n   * Check VRF worker status\n   */\n  async checkVrfStatus(): Promise<{ active: boolean; nearAccountId: AccountId | null; sessionDuration?: number }> {\n    return this.vrfWorkerManager.checkVrfStatus();\n  }\n\n  ///////////////////////////////////////\n  // INDEXEDDB OPERATIONS\n  ///////////////////////////////////////\n\n  async storeUserData(userData: StoreUserDataInput): Promise<void> {\n    await IndexedDBManager.clientDB.storeWebAuthnUserData(userData);\n  }\n\n  async getUser(nearAccountId: AccountId): Promise<ClientUserData | null> {\n    return await IndexedDBManager.clientDB.getUser(nearAccountId);\n  }\n\n  async getAllUserData(): Promise<ClientUserData[]> {\n    return await IndexedDBManager.clientDB.getAllUsers();\n  }\n\n  async getAllUsers(): Promise<ClientUserData[]> {\n    return await IndexedDBManager.clientDB.getAllUsers();\n  }\n\n  async getAuthenticatorsByUser(nearAccountId: AccountId): Promise<ClientAuthenticatorData[]> {\n    return await IndexedDBManager.clientDB.getAuthenticatorsByUser(nearAccountId);\n  }\n\n  async updateLastLogin(nearAccountId: AccountId): Promise<void> {\n    return await IndexedDBManager.clientDB.updateLastLogin(nearAccountId);\n  }\n\n  /**\n   * Set the last logged-in user\n   * @param nearAccountId - The account ID of the user\n   * @param deviceNumber - The device number (defaults to 1)\n   */\n  async setLastUser(nearAccountId: AccountId, deviceNumber: number = 1): Promise<void> {\n    return await IndexedDBManager.clientDB.setLastUser(nearAccountId, deviceNumber);\n  }\n\n  async setCurrentUser(nearAccountId: AccountId): Promise<void> {\n    this.userPreferencesManager.setCurrentUser(nearAccountId);\n\n    // Also initialize NonceManager with user data\n    const userData = await IndexedDBManager.clientDB.getLastUser();\n    if (userData && userData.clientNearPublicKey) {\n      this.nonceManager.initializeUser(nearAccountId, userData.clientNearPublicKey);\n    }\n  }\n\n  async registerUser(storeUserData: StoreUserDataInput): Promise<ClientUserData> {\n    return await IndexedDBManager.clientDB.registerUser(storeUserData);\n  }\n\n  async storeAuthenticator(authenticatorData: {\n    credentialId: string;\n    credentialPublicKey: Uint8Array;\n    transports?: string[];\n    name?: string;\n    nearAccountId: AccountId;\n    registered: string;\n    syncedAt: string;\n    vrfPublicKey: string;\n    deviceNumber?: number;\n  }): Promise<void> {\n    const authData = {\n      ...authenticatorData,\n      nearAccountId: toAccountId(authenticatorData.nearAccountId),\n      deviceNumber: authenticatorData.deviceNumber || 1 // Default to device 1 (1-indexed)\n    };\n    return await IndexedDBManager.clientDB.storeAuthenticator(authData);\n  }\n\n  extractUsername(nearAccountId: AccountId): string {\n    return IndexedDBManager.clientDB.extractUsername(nearAccountId);\n  }\n\n  async atomicOperation<T>(callback: (db: any) => Promise<T>): Promise<T> {\n    return await IndexedDBManager.clientDB.atomicOperation(callback);\n  }\n\n  async rollbackUserRegistration(nearAccountId: AccountId): Promise<void> {\n    return await IndexedDBManager.clientDB.rollbackUserRegistration(nearAccountId);\n  }\n\n  async hasPasskeyCredential(nearAccountId: AccountId): Promise<boolean> {\n    return await IndexedDBManager.clientDB.hasPasskeyCredential(nearAccountId);\n  }\n\n  async getLastUsedNearAccountId(): Promise<{\n    nearAccountId: AccountId;\n    deviceNumber: number;\n  } | null> {\n    const lastUser = await IndexedDBManager.clientDB.getLastUser();\n    if (!lastUser) return null;\n    return {\n      nearAccountId: lastUser.nearAccountId,\n      deviceNumber: lastUser.deviceNumber,\n    };\n  }\n\n  /**\n   * Atomically store all registration data (user, authenticator, VRF credentials)\n   */\n  async atomicStoreRegistrationData({\n    nearAccountId,\n    credential,\n    publicKey,\n    encryptedVrfKeypair,\n    vrfPublicKey,\n    serverEncryptedVrfKeypair,\n    onEvent\n  }: {\n    nearAccountId: AccountId;\n    credential: PublicKeyCredential;\n    publicKey: string;\n    encryptedVrfKeypair: EncryptedVRFKeypair;\n    vrfPublicKey: string;\n    serverEncryptedVrfKeypair: ServerEncryptedVrfKeypair | null;\n    onEvent?: (event: any) => void;\n  }): Promise<void> {\n\n    await this.atomicOperation(async (db) => {\n\n      // Store credential for authentication\n      const credentialId = base64UrlEncode(credential.rawId);\n      const response = credential.response as AuthenticatorAttestationResponse;\n\n      await this.storeAuthenticator({\n        nearAccountId: nearAccountId,\n        credentialId: credentialId,\n        credentialPublicKey: await this.extractCosePublicKey(\n          base64UrlEncode(response.attestationObject)\n        ),\n        transports: response.getTransports?.() || [],\n        name: `VRF Passkey for ${this.extractUsername(nearAccountId)}`,\n        registered: new Date().toISOString(),\n        syncedAt: new Date().toISOString(),\n        vrfPublicKey: vrfPublicKey,\n      });\n\n      // Store WebAuthn user data with encrypted VRF credentials\n      await this.storeUserData({\n        nearAccountId,\n        clientNearPublicKey: publicKey,\n        lastUpdated: Date.now(),\n        passkeyCredential: {\n          id: credential.id,\n          rawId: credentialId\n        },\n        encryptedVrfKeypair: {\n          encryptedVrfDataB64u: encryptedVrfKeypair.encryptedVrfDataB64u,\n          chacha20NonceB64u: encryptedVrfKeypair.chacha20NonceB64u,\n        },\n        serverEncryptedVrfKeypair: serverEncryptedVrfKeypair ? {\n          ciphertextVrfB64u: serverEncryptedVrfKeypair?.ciphertextVrfB64u,\n          kek_s_b64u: serverEncryptedVrfKeypair?.kek_s_b64u,\n        } : undefined,\n      });\n\n      console.debug('Registration data stored atomically');\n      return true;\n    });\n\n    onEvent?.({\n      step: 5,\n      phase: 'database-storage',\n      status: 'success',\n      message: 'VRF registration data stored successfully'\n    });\n  }\n\n  ///////////////////////////////////////\n  // SIGNER WASM WORKER OPERATIONS\n  ///////////////////////////////////////\n\n  /**\n   * Secure registration flow with PRF: WebAuthn + WASM worker encryption using PRF\n   * Optionally signs a link_device_register_user transaction if VRF data is provided\n   */\n  async deriveNearKeypairAndEncrypt({\n    nearAccountId,\n    credential,\n    options\n  }: {\n    credential: PublicKeyCredential;\n    nearAccountId: AccountId;\n    options?: {\n      vrfChallenge: VRFChallenge;\n      deterministicVrfPublicKey: string; // Add VRF public key for registration transactions\n      contractId: string;\n      nonce: string;\n      blockHash: string;\n    };\n  }): Promise<{\n    success: boolean;\n    nearAccountId: AccountId;\n    publicKey: string;\n    signedTransaction?: SignedTransaction;\n  }> {\n    return await this.signerWorkerManager.deriveNearKeypairAndEncrypt({\n      credential,\n      nearAccountId,\n      options,\n    });\n  }\n\n  /**\n   * Export private key using PRF-based decryption. Requires TouchId\n   */\n  async exportNearKeypairWithTouchId(nearAccountId: AccountId): Promise<{\n    accountId: string,\n    publicKey: string,\n    privateKey: string\n  }> {\n    console.debug(`ðŸ” Exporting private key for account: ${nearAccountId}`);\n    // Get user data to verify user exists\n    const userData = await this.getUser(nearAccountId);\n    if (!userData) {\n      throw new Error(`No user data found for ${nearAccountId}`);\n    }\n    if (!userData.clientNearPublicKey) {\n      throw new Error(`No public key found for ${nearAccountId}`);\n    }\n    // Get stored authenticator data for this user\n    const authenticators = await this.getAuthenticatorsByUser(nearAccountId);\n    if (authenticators.length === 0) {\n      throw new Error(`No authenticators found for account ${nearAccountId}. Please register first.`);\n    }\n\n    // Use WASM worker to decrypt private key\n    const decryptionResult = await this.signerWorkerManager.decryptPrivateKeyWithPrf({\n      nearAccountId,\n      authenticators,\n    });\n\n    return {\n      accountId: userData.nearAccountId,\n      publicKey: userData.clientNearPublicKey,\n      privateKey: decryptionResult.decryptedPrivateKey,\n    }\n  }\n\n  /**\n   * Transaction signing with contract verification and progress updates.\n   * Demonstrates the \"streaming\" worker pattern similar to SSE.\n   *\n   * Requires a successful TouchID/biometric prompt before transaction signing in wasm worker\n   * Automatically verifies the authentication with the web3authn contract.\n   *\n   * @param transactions - Transaction payload containing:\n   *   - receiverId: NEAR account ID receiving the transaction\n   *   - actions: Array of NEAR actions to execute\n   * @param rpcCall: RpcCallPayload containing:\n   *   - contractId: Web3Authn contract ID for verification\n   *   - nearRpcUrl: NEAR RPC endpoint URL\n   *   - nearAccountId: NEAR account ID performing the transaction\n   * @param confirmationConfigOverride: Optional confirmation configuration override\n   * @param onEvent: Optional callback for progress updates during signing\n   * @param onEvent - Optional callback for progress updates during signing\n   */\n  async signTransactionsWithActions({\n    transactions,\n    rpcCall,\n    confirmationConfigOverride,\n    onEvent,\n  }: {\n    transactions: TransactionInputWasm[],\n    rpcCall: RpcCallPayload,\n    confirmationConfigOverride?: ConfirmationConfig,\n    onEvent?: (update: onProgressEvents) => void,\n  }): Promise<VerifyAndSignTransactionResult[]> {\n\n    if (transactions.length === 0) {\n      throw new Error('No payloads provided for signing');\n    }\n    return await this.signerWorkerManager.signTransactionsWithActions({\n      transactions,\n      rpcCall,\n      confirmationConfigOverride,\n      onEvent,\n    });\n  }\n\n  async signNEP413Message(payload: {\n    message: string;\n    recipient: string;\n    nonce: string;\n    state: string | null;\n    accountId: AccountId;\n    credential: PublicKeyCredential;\n  }): Promise<{\n    success: boolean;\n    accountId: string;\n    publicKey: string;\n    signature: string;\n    state?: string;\n    error?: string;\n  }> {\n    try {\n      // Send to WASM worker for signing\n      const result = await this.signerWorkerManager.signNep413Message(payload);\n      if (result.success) {\n        console.debug('WebAuthnManager: NEP-413 message signed successfully');\n        return result;\n      } else {\n        throw new Error(`NEP-413 signing failed: ${result.error || 'Unknown error'}`);\n      }\n    } catch (error: any) {\n      console.error('WebAuthnManager: NEP-413 signing error:', error);\n      return {\n        success: false,\n        accountId: '',\n        publicKey: '',\n        signature: '',\n        error: error.message || 'Unknown error'\n      };\n    }\n  }\n\n  // === COSE OPERATIONS ===\n\n  /**\n   * Extract COSE public key from WebAuthn attestation object using WASM worker\n   */\n  async extractCosePublicKey(attestationObjectBase64url: string): Promise<Uint8Array> {\n    return await this.signerWorkerManager.extractCosePublicKey(attestationObjectBase64url);\n  }\n\n  ///////////////////////////////////////\n  // REGISTRATION\n  ///////////////////////////////////////\n\n  async checkCanRegisterUser({\n    contractId,\n    credential,\n    vrfChallenge,\n    authenticatorOptions,\n    onEvent,\n  }: {\n    contractId: string,\n    credential: PublicKeyCredential,\n    vrfChallenge: VRFChallenge,\n    authenticatorOptions?: AuthenticatorOptions;\n    onEvent?: (update: onProgressEvents) => void\n  }): Promise<{\n    success: boolean;\n    verified?: boolean;\n    registrationInfo?: any;\n    logs?: string[];\n    signedTransactionBorsh?: number[];\n    error?: string;\n  }> {\n    return await this.signerWorkerManager.checkCanRegisterUser({\n      contractId,\n      credential,\n      vrfChallenge,\n      authenticatorOptions,\n      onEvent,\n      nearRpcUrl: this.passkeyManagerConfigs.nearRpcUrl,\n    });\n  }\n\n  /**\n   * Register user on-chain with transaction (STATE-CHANGING)\n   * This performs the actual on-chain registration transaction\n   * @deprecated Testnet only, use createAccountAndRegisterWithRelayServer instead for prod\n   */\n  async signVerifyAndRegisterUser({\n    contractId,\n    credential,\n    vrfChallenge,\n    deterministicVrfPublicKey,\n    nearAccountId,\n    nearPublicKeyStr,\n    nearClient,\n    deviceNumber = 1, // Default to device number 1 for first device (1-indexed)\n    authenticatorOptions,\n    onEvent,\n  }: {\n    contractId: string,\n    credential: PublicKeyCredential,\n    vrfChallenge: VRFChallenge,\n    deterministicVrfPublicKey: string, // deterministic VRF key for key recovery\n    nearAccountId: AccountId;\n    nearPublicKeyStr: string;\n    nearClient: NearClient;\n    deviceNumber?: number; // Device number for multi-device support (defaults to 1)\n    authenticatorOptions?: AuthenticatorOptions; // Authenticator options for registration\n    onEvent?: (update: onProgressEvents) => void;\n  }): Promise<{\n    success: boolean;\n    verified: boolean;\n    registrationInfo?: any;\n    logs?: string[];\n    signedTransaction: SignedTransaction;\n    preSignedDeleteTransaction: SignedTransaction | null;\n    error?: string;\n  }> {\n    try {\n      const registrationResult = await this.signerWorkerManager.signVerifyAndRegisterUser({\n        vrfChallenge,\n        credential,\n        contractId,\n        deterministicVrfPublicKey, // Pass through the deterministic VRF key\n        nearAccountId,\n        nearPublicKeyStr,\n        nearClient,\n        deviceNumber, // Pass device number for multi-device support\n        authenticatorOptions, // Pass authenticator options\n        onEvent,\n        nearRpcUrl: this.passkeyManagerConfigs.nearRpcUrl,\n      });\n\n      console.debug(\"On-chain registration completed:\", registrationResult);\n\n      if (registrationResult.verified) {\n        console.debug('On-chain user registration successful');\n        return {\n          success: true,\n          verified: registrationResult.verified,\n          registrationInfo: registrationResult.registrationInfo,\n          logs: registrationResult.logs,\n          signedTransaction: registrationResult.signedTransaction,\n          preSignedDeleteTransaction: registrationResult.preSignedDeleteTransaction,\n        };\n      } else {\n        console.warn('On-chain user registration failed - WASM worker returned unverified result');\n        throw new Error('On-chain registration transaction failed');\n      }\n    } catch (error: any) {\n      console.error('WebAuthnManager: On-chain registration error:', error);\n      throw error;\n    }\n  }\n\n  ///////////////////////////////////////\n  // ACCOUNT RECOVERY\n  ///////////////////////////////////////\n\n  /**\n   * Recover keypair from authentication credential for account recovery\n   * Uses dual PRF outputs to re-derive the same NEAR keypair and re-encrypt it\n   * @param challenge - Random challenge for WebAuthn authentication ceremony\n   * @param authenticationCredential - The authentication credential with dual PRF outputs\n   * @param accountIdHint - Optional account ID hint for recovery\n   * @returns Public key and encrypted private key for secure storage\n   */\n  async recoverKeypairFromPasskey(\n    authenticationCredential: PublicKeyCredential,\n    accountIdHint?: string,\n  ): Promise<{\n    publicKey: string;\n    encryptedPrivateKey: string;\n    iv: string;\n    accountIdHint?: string;\n    stored?: boolean;\n  }> {\n    try {\n      console.debug('WebAuthnManager: recovering keypair from authentication credential with dual PRF outputs');\n\n      // Verify we have an authentication credential (not registration)\n      if (!authenticationCredential) {\n        throw new Error(\n          'Authentication credential required for account recovery. ' +\n          'Use an existing credential with dual PRF outputs to re-derive the same NEAR keypair.'\n        );\n      }\n\n      // Verify dual PRF outputs are available\n      const prfResults = authenticationCredential.getClientExtensionResults()?.prf?.results;\n      if (!prfResults?.first || !prfResults?.second) {\n        throw new Error('Dual PRF outputs required for account recovery - both AES and Ed25519 PRF outputs must be available');\n      }\n\n      // Call the WASM worker to derive and encrypt the keypair using dual PRF\n      const result = await this.signerWorkerManager.recoverKeypairFromPasskey({\n        credential: authenticationCredential,\n        accountIdHint,\n      });\n\n       console.debug('WebAuthnManager: Deterministic keypair derivation successful');\n       return result;\n\n    } catch (error: any) {\n      console.error('WebAuthnManager: Deterministic keypair derivation error:', error);\n      throw new Error(`Deterministic keypair derivation failed: ${error.message}`);\n    }\n  }\n\n  async generateRegistrationCredentials({ nearAccountId, challenge }: {\n    nearAccountId: AccountId;\n    challenge: VRFChallenge;\n  }): Promise<PublicKeyCredential> {\n    return this.touchIdPrompt.generateRegistrationCredentials({ nearAccountId, challenge });\n  }\n\n  async generateRegistrationCredentialsForLinkDevice({\n    nearAccountId,\n    challenge,\n    deviceNumber,\n  }: {\n    nearAccountId: AccountId;\n    challenge: VRFChallenge;\n    deviceNumber: number;\n  }): Promise<PublicKeyCredential> {\n    return this.touchIdPrompt.generateRegistrationCredentialsForLinkDevice({ nearAccountId, challenge, deviceNumber });\n  }\n\n  async getCredentialsForRecovery({\n    nearAccountId,\n    challenge,\n    credentialIds,\n  }: {\n    nearAccountId: AccountId;\n    challenge: VRFChallenge,\n    credentialIds: string[];\n  }): Promise<PublicKeyCredential> {\n    return this.touchIdPrompt.getCredentialsForRecovery({ nearAccountId, challenge, credentialIds });\n  }\n\n  /**\n   * Sign transaction with raw private key\n   * for key replacement in device linking\n   * No TouchID/PRF required - uses provided private key directly\n   */\n  async signTransactionWithKeyPair({\n    nearPrivateKey,\n    signerAccountId,\n    receiverId,\n    nonce,\n    blockHash,\n    actions\n  }: {\n    nearPrivateKey: string;\n    signerAccountId: string;\n    receiverId: string;\n    nonce: string;\n    blockHash: string;\n    actions: ActionArgsWasm[];\n  }): Promise<{\n    signedTransaction: SignedTransaction;\n    logs?: string[];\n  }> {\n    return await this.signerWorkerManager.signTransactionWithKeyPair({\n      nearPrivateKey,\n      signerAccountId,\n      receiverId,\n      nonce,\n      blockHash,\n      actions\n    });\n  }\n\n  // ==============================\n  // USER SETTINGS\n  // ==============================\n\n  /**\n   * Get user preferences manager\n   */\n  getUserPreferences(): UserPreferencesManager {\n    return this.userPreferencesManager;\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy(): void {\n    if (this.userPreferencesManager) {\n      this.userPreferencesManager.destroy();\n    }\n    if (this.nonceManager) {\n      this.nonceManager.clear();\n    }\n  }\n\n}\n"],"mappings":"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"}