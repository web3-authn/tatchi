# Shamir3Pass Server Key Rotation — Implemented Design

- Scope: VRF auto-login via commutative Shamir 3‑pass with server key rotation
- Status: Implemented (strict keyId mode, fallback refresh, proactive refresh)

## Overview

- Client stores a server‑assisted auto‑login blob in IndexedDB: `serverEncryptedVrfKeypair`.
- When the relay server rotates Shamir3Pass exponents `(e_s, d_s)`, old KEKs stop unlocking on the server.
- The SDK handles rotation by refreshing the stored blob after a successful TouchID fallback, and proactively when it detects a key change.

## Data Model (Client)

- IndexedDB `serverEncryptedVrfKeypair` fields (stored per user):
  - `ciphertextVrfB64u`: AEAD ciphertext over the VRF keypair bytes.
  - `kek_s_b64u`: server‑locked KEK (client already removed its one‑time lock).
  - `serverKeyId`: ID of the server key that applied the lock (sha256 of `e_s_b64u`, base64url).
  - `updatedAt`: milliseconds since epoch (added by migration v13 on write).

Types: see `passkey-sdk/src/core/types/vrf-worker.ts:132` and `passkey-sdk/src/core/IndexedDBManager/passkeyClientDB.ts:33`.

## Client Behavior

- Registration/Derivation
  - Worker derives a deterministic VRF keypair from PRF and optionally generates a VRF challenge.
  - If a relay server is configured, the worker performs Shamir client encrypt and calls the relay `/vrf/apply-server-lock`.
  - Result includes `{ ciphertextVrfB64u, kek_s_b64u, serverKeyId }` which is persisted to IndexedDB.
  - Code: `passkey-sdk/src/wasm_vrf_worker/src/handlers/handle_derive_vrf_keypair_from_prf.rs:84`.

- Login Path
  - Attempt Shamir unlock first (no TouchID): uses stored `ciphertextVrfB64u`, `kek_s_b64u`, and `serverKeyId`.
  - On success, ensure VRF session active and run `maybeProactiveShamirRefresh` to migrate to the current server key if needed.
  - On failure, fall back to TouchID unlock of the encrypted VRF keypair (PRF‑based decrypt), then immediately re‑encrypt under the current server key and persist.
  - Code: `passkey-sdk/src/core/PasskeyManager/login.ts:155` and `:240`.

- Proactive Refresh
  - After a successful Shamir unlock, the manager fetches `GET /shamir/key-info` and compares `currentKeyId` to stored `serverKeyId`.
  - If different and the VRF session is active, it re‑encrypts the in‑memory VRF keypair under the new key and updates IndexedDB.
  - Code: `passkey-sdk/src/core/WebAuthnManager/index.ts:459`.

## WASM VRF Worker (Client)

- Handlers
  - `DERIVE_VRF_KEYPAIR_FROM_PRF`: derives VRF; when server URLs are configured, performs Shamir client encrypt and returns `serverEncryptedVrfKeypair`.
    - Code: `passkey-sdk/src/wasm_vrf_worker/src/handlers/handle_derive_vrf_keypair_from_prf.rs:84`.
  - `SHAMIR3PASS_CLIENT_ENCRYPT_CURRENT_VRF_KEYPAIR`: encrypts the currently unlocked VRF keypair and returns `{ ciphertextVrfB64u, kek_s_b64u, serverKeyId }`.
    - Code: `passkey-sdk/src/wasm_vrf_worker/src/handlers/handle_shamir3pass_client.rs:18` and `:77`.
  - `SHAMIR3PASS_CLIENT_DECRYPT_VRF_KEYPAIR`: Shamir unlock + decrypt; requires `keyId` (strict) to select the correct server key.
    - Code: `passkey-sdk/src/wasm_vrf_worker/src/handlers/handle_shamir3pass_client.rs:25` and `:151`.

- HTTP Types (strict keyId mode)
  - `POST /vrf/apply-server-lock` response: `{ kek_cs_b64u, keyId?: string }` (keyId propagated to result if provided).
  - `POST /vrf/remove-server-lock` request: `{ kek_cs_b64u, keyId: string }` (required).
  - Code: `passkey-sdk/src/wasm_vrf_worker/src/http.rs` and `passkey-sdk/src/wasm_vrf_worker/src/types/http.rs`.

## Relay Server API (Strict keyId)

- `POST /vrf/apply-server-lock`
  - Request: `{ kek_c_b64u }`
  - Response: `{ kek_cs_b64u, keyId }` (keyId = sha256 of active `e_s_b64u`, base64url).

- `POST /vrf/remove-server-lock`
  - Request: `{ kek_cs_b64u, keyId }` (keyId required; server rejects missing/unknown IDs).
  - Response: `{ kek_c_b64u }`.

- `GET /shamir/key-info`
  - Response: `{ currentKeyId, p_b64u, graceKeyIds }` for proactive refresh and diagnostics.

References: `examples/relay-server/src/index.ts:84` and `passkey-sdk/src/server/core/AuthService.ts:954`.

## Server Key Rotation (Relay)

- Rotation API
  - `AuthService.rotateShamirServerKeypair({ keepCurrentInGrace?: true, persistGraceToDisk?: true })` swaps in a fresh keypair and retains the previous key as a grace key.
  - `AuthService.generateShamirServerKeypair()` previews a new pair without swapping.
  - Code: `passkey-sdk/src/server/core/AuthService.ts:416` and `:390`.

- Grace Keys
  - Server maintains a map of grace keys; only used for `remove-server-lock` (unwrap) when `keyId` matches a grace entry.
  - Grace set is persisted to `grace-keys.json` (configurable) and exposed via optional admin helpers.
  - Code: `AuthService` grace load/persist helpers around `:240–360` and `:1088–1139`.

## Strict KeyId Mode (Enforced)

- Server
  - `remove-server-lock` requires `keyId` and deterministically selects either the active key or a matching grace key; otherwise responds `400`.
  - `apply-server-lock` includes `keyId` so clients can tag stored blobs.

- WASM/Client
  - Remove‑lock request types require `keyId` end‑to‑end.
  - `ServerEncryptedVrfKeypair.serverKeyId` is required client‑side; Shamir auto‑unlock is attempted only when present, otherwise the SDK uses TouchID and refreshes.

## Security Notes

- Server never sees plaintext VRF or KEK; only blinded KEKs (`kek_c`, `kek_cs`) and returns partial unwraps.
- keyId prevents ambiguous key selection after rotations and removes guesswork server‑side.
- Grace keys allow short migration windows; prefer trimming the grace list quickly once clients refresh.

## File References

- Client flows: passkey-sdk/src/core/PasskeyManager/login.ts:155
- Proactive refresh: passkey-sdk/src/core/WebAuthnManager/index.ts:459
- WASM handlers: passkey-sdk/src/wasm_vrf_worker/src/handlers/handle_shamir3pass_client.rs:18
- HTTP types: passkey-sdk/src/wasm_vrf_worker/src/types/http.rs:1
- Relay endpoints: examples/relay-server/src/index.ts:84
- Rotation: passkey-sdk/src/server/core/AuthService.ts:416

## Rotating In Production - Checklist

- Prepare
  - Persist `SHAMIR_P_B64U`, `SHAMIR_E_S_B64U`, `SHAMIR_D_S_B64U` in a secure store.
  - Boot service and verify `GET /shamir/key-info` returns `currentKeyId`.

- Rotate
  - Call `AuthService.rotateShamirServerKeypair({ keepCurrentInGrace: true, persistGraceToDisk: true })`.
  - Persist the returned `newKeypair` (`e_s_b64u`, `d_s_b64u`) to your secret store.

- Client migration
  - Clients include `serverKeyId` in stored blobs and in remove‑lock requests automatically.
  - After rotation, clients either proactively refresh (if VRF session active) or refresh after a TouchID fallback.

- Monitor
  - `GET /shamir/key-info` shows the active `currentKeyId` and `graceKeyIds`.
  - Track 400 `unknown keyId` on `/vrf/remove-server-lock` (should be rare and drop to zero during the window).
  - Check that new `keyId` appears on `/vrf/apply-server-lock` responses.

- Prune
  - After your grace window, remove old keys: use `handleRemoveGraceKey({ keyId })` or delete from `grace-keys.json` then reload.
  - Keep the grace set small (example server trims to 5).

- Automate (optional)
  - Use the example server’s scheduler (see `startKeyRotationCronjob`) via `ROTATE_EVERY` minutes.
  - Or run your own cron calling `rotateShamirServerKeypair` and persisting new exponents.

