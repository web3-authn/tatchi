{
  "version": 3,
  "sources": ["../../../../../../../node_modules/.pnpm/@noble+ed25519@2.3.0/node_modules/@noble/ed25519/index.js"],
  "sourcesContent": ["/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n/**\n * 4KB JS implementation of ed25519 EdDSA signatures.\n * Compliant with RFC8032, FIPS 186-5 & ZIP215.\n * @module\n * @example\n * ```js\nimport * as ed from '@noble/ed25519';\n(async () => {\n  const privKey = ed.utils.randomPrivateKey();\n  const message = Uint8Array.from([0xab, 0xbc, 0xcd, 0xde]);\n  const pubKey = await ed.getPublicKeyAsync(privKey); // Sync methods are also present\n  const signature = await ed.signAsync(message, privKey);\n  const isValid = await ed.verifyAsync(signature, message, pubKey);\n})();\n```\n */\n/**\n * Curve params. ed25519 is twisted edwards curve. Equation is −x² + y² = -a + dx²y².\n * * P = `2n**255n - 19n` // field over which calculations are done\n * * N = `2n**252n + 27742317777372353535851937790883648493n` // group order, amount of curve points\n * * h = 8 // cofactor\n * * a = `Fp.create(BigInt(-1))` // equation param\n * * d = -121665/121666 a.k.a. `Fp.neg(121665 * Fp.inv(121666))` // equation param\n * * Gx, Gy are coordinates of Generator / base point\n */\nconst ed25519_CURVE = {\n    p: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedn,\n    n: 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3edn,\n    h: 8n,\n    a: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffecn,\n    d: 0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3n,\n    Gx: 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an,\n    Gy: 0x6666666666666666666666666666666666666666666666666666666666666658n,\n};\nconst { p: P, n: N, Gx, Gy, a: _a, d: _d } = ed25519_CURVE;\nconst h = 8n; // cofactor\nconst L = 32; // field / group byte length\nconst L2 = 64;\n// Helpers and Precomputes sections are reused between libraries\n// ## Helpers\n// ----------\n// error helper, messes-up stack trace\nconst err = (m = '') => {\n    throw new Error(m);\n};\nconst isBig = (n) => typeof n === 'bigint'; // is big integer\nconst isStr = (s) => typeof s === 'string'; // is string\nconst isBytes = (a) => a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n/** assert is Uint8Array (of specific length) */\nconst abytes = (a, l) => !isBytes(a) || (typeof l === 'number' && l > 0 && a.length !== l)\n    ? err('Uint8Array expected')\n    : a;\n/** create Uint8Array */\nconst u8n = (len) => new Uint8Array(len);\nconst u8fr = (buf) => Uint8Array.from(buf);\nconst padh = (n, pad) => n.toString(16).padStart(pad, '0');\nconst bytesToHex = (b) => Array.from(abytes(b))\n    .map((e) => padh(e, 2))\n    .join('');\nconst C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }; // ASCII characters\nconst _ch = (ch) => {\n    if (ch >= C._0 && ch <= C._9)\n        return ch - C._0; // '2' => 50-48\n    if (ch >= C.A && ch <= C.F)\n        return ch - (C.A - 10); // 'B' => 66-(65-10)\n    if (ch >= C.a && ch <= C.f)\n        return ch - (C.a - 10); // 'b' => 98-(97-10)\n    return;\n};\nconst hexToBytes = (hex) => {\n    const e = 'hex invalid';\n    if (!isStr(hex))\n        return err(e);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        return err(e);\n    const array = u8n(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        // treat each char as ASCII\n        const n1 = _ch(hex.charCodeAt(hi)); // parse first char, multiply it by 16\n        const n2 = _ch(hex.charCodeAt(hi + 1)); // parse second char\n        if (n1 === undefined || n2 === undefined)\n            return err(e);\n        array[ai] = n1 * 16 + n2; // example: 'A9' => 10*16 + 9\n    }\n    return array;\n};\n/** normalize hex or ui8a to ui8a */\nconst toU8 = (a, len) => abytes(isStr(a) ? hexToBytes(a) : u8fr(abytes(a)), len);\nconst cr = () => globalThis?.crypto; // WebCrypto is available in all modern environments\nconst subtle = () => cr()?.subtle ?? err('crypto.subtle must be defined');\n// prettier-ignore\nconst concatBytes = (...arrs) => {\n    const r = u8n(arrs.reduce((sum, a) => sum + abytes(a).length, 0)); // create u8a of summed length\n    let pad = 0; // walk through each array,\n    arrs.forEach(a => { r.set(a, pad); pad += a.length; }); // ensure they have proper type\n    return r;\n};\n/** WebCrypto OS-level CSPRNG (random number generator). Will throw when not available. */\nconst randomBytes = (len = L) => {\n    const c = cr();\n    return c.getRandomValues(u8n(len));\n};\nconst big = BigInt;\nconst arange = (n, min, max, msg = 'bad number: out of range') => isBig(n) && min <= n && n < max ? n : err(msg);\n/** modular division */\nconst M = (a, b = P) => {\n    const r = a % b;\n    return r >= 0n ? r : b + r;\n};\nconst modN = (a) => M(a, N);\n/** Modular inversion using eucledian GCD (non-CT). No negative exponent for now. */\n// prettier-ignore\nconst invert = (num, md) => {\n    if (num === 0n || md <= 0n)\n        err('no inverse n=' + num + ' mod=' + md);\n    let a = M(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;\n    while (a !== 0n) {\n        const q = b / a, r = b % a;\n        const m = x - u * q, n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    return b === 1n ? M(x, md) : err('no inverse'); // b is gcd at this point\n};\nconst callHash = (name) => {\n    // @ts-ignore\n    const fn = etc[name];\n    if (typeof fn !== 'function')\n        err('hashes.' + name + ' not set');\n    return fn;\n};\nconst apoint = (p) => (p instanceof Point ? p : err('Point expected'));\n// ## End of Helpers\n// -----------------\nconst B256 = 2n ** 256n;\n/** Point in XYZT extended coordinates. */\nclass Point {\n    static BASE;\n    static ZERO;\n    ex;\n    ey;\n    ez;\n    et;\n    constructor(ex, ey, ez, et) {\n        const max = B256;\n        this.ex = arange(ex, 0n, max);\n        this.ey = arange(ey, 0n, max);\n        this.ez = arange(ez, 1n, max);\n        this.et = arange(et, 0n, max);\n        Object.freeze(this);\n    }\n    static fromAffine(p) {\n        return new Point(p.x, p.y, 1n, M(p.x * p.y));\n    }\n    /** RFC8032 5.1.3: Uint8Array to Point. */\n    static fromBytes(hex, zip215 = false) {\n        const d = _d;\n        // Copy array to not mess it up.\n        const normed = u8fr(abytes(hex, L));\n        // adjust first LE byte = last BE byte\n        const lastByte = hex[31];\n        normed[31] = lastByte & ~0x80;\n        const y = bytesToNumLE(normed);\n        // zip215=true:           0 <= y < 2^256\n        // zip215=false, RFC8032: 0 <= y < 2^255-19\n        const max = zip215 ? B256 : P;\n        arange(y, 0n, max);\n        const y2 = M(y * y); // y²\n        const u = M(y2 - 1n); // u=y²-1\n        const v = M(d * y2 + 1n); // v=dy²+1\n        let { isValid, value: x } = uvRatio(u, v); // (uv³)(uv⁷)^(p-5)/8; square root\n        if (!isValid)\n            err('bad point: y not sqrt'); // not square root: bad point\n        const isXOdd = (x & 1n) === 1n; // adjust sign of x coordinate\n        const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n        if (!zip215 && x === 0n && isLastByteOdd)\n            err('bad point: x==0, isLastByteOdd'); // x=0, x_0=1\n        if (isLastByteOdd !== isXOdd)\n            x = M(-x);\n        return new Point(x, y, 1n, M(x * y)); // Z=1, T=xy\n    }\n    /** Checks if the point is valid and on-curve. */\n    assertValidity() {\n        const a = _a;\n        const d = _d;\n        const p = this;\n        if (p.is0())\n            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n        const { ex: X, ey: Y, ez: Z, et: T } = p;\n        const X2 = M(X * X); // X²\n        const Y2 = M(Y * Y); // Y²\n        const Z2 = M(Z * Z); // Z²\n        const Z4 = M(Z2 * Z2); // Z⁴\n        const aX2 = M(X2 * a); // aX²\n        const left = M(Z2 * M(aX2 + Y2)); // (aX² + Y²)Z²\n        const right = M(Z4 + M(d * M(X2 * Y2))); // Z⁴ + dX²Y²\n        if (left !== right)\n            throw new Error('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = M(X * Y);\n        const ZT = M(Z * T);\n        if (XY !== ZT)\n            throw new Error('bad point: equation left != right (2)');\n        return this;\n    }\n    /** Equality check: compare points P&Q. */\n    equals(other) {\n        const { ex: X1, ey: Y1, ez: Z1 } = this;\n        const { ex: X2, ey: Y2, ez: Z2 } = apoint(other); // checks class equality\n        const X1Z2 = M(X1 * Z2);\n        const X2Z1 = M(X2 * Z1);\n        const Y1Z2 = M(Y1 * Z2);\n        const Y2Z1 = M(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() {\n        return this.equals(I);\n    }\n    /** Flip point over y coordinate. */\n    negate() {\n        return new Point(M(-this.ex), this.ey, this.ez, M(-this.et));\n    }\n    /** Point doubling. Complete formula. Cost: `4M + 4S + 1*a + 6add + 1*2`. */\n    double() {\n        const { ex: X1, ey: Y1, ez: Z1 } = this;\n        const a = _a;\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        const A = M(X1 * X1);\n        const B = M(Y1 * Y1);\n        const C = M(2n * M(Z1 * Z1));\n        const D = M(a * A);\n        const x1y1 = X1 + Y1;\n        const E = M(M(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = M(E * F);\n        const Y3 = M(G * H);\n        const T3 = M(E * H);\n        const Z3 = M(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    /** Point addition. Complete formula. Cost: `8M + 1*k + 8add + 1*2`. */\n    add(other) {\n        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = apoint(other); // doesn't check if other on-curve\n        const a = _a;\n        const d = _d;\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3\n        const A = M(X1 * X2);\n        const B = M(Y1 * Y2);\n        const C = M(T1 * d * T2);\n        const D = M(Z1 * Z2);\n        const E = M((X1 + Y1) * (X2 + Y2) - A - B);\n        const F = M(D - C);\n        const G = M(D + C);\n        const H = M(B - a * A);\n        const X3 = M(E * F);\n        const Y3 = M(G * H);\n        const T3 = M(E * H);\n        const Z3 = M(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    /**\n     * Point-by-scalar multiplication. Scalar must be in range 1 <= n < CURVE.n.\n     * Uses {@link wNAF} for base point.\n     * Uses fake point to mitigate side-channel leakage.\n     * @param n scalar by which point is multiplied\n     * @param safe safe mode guards against timing attacks; unsafe mode is faster\n     */\n    multiply(n, safe = true) {\n        if (!safe && (n === 0n || this.is0()))\n            return I;\n        arange(n, 1n, N);\n        if (n === 1n)\n            return this;\n        if (this.equals(G))\n            return wNAF(n).p;\n        // init result point & fake point\n        let p = I;\n        let f = G;\n        for (let d = this; n > 0n; d = d.double(), n >>= 1n) {\n            // if bit is present, add to point\n            // if not present, add to fake, for timing safety\n            if (n & 1n)\n                p = p.add(d);\n            else if (safe)\n                f = f.add(d);\n        }\n        return p;\n    }\n    /** Convert point to 2d xy affine point. (X, Y, Z) ∋ (x=X/Z, y=Y/Z) */\n    toAffine() {\n        const { ex: x, ey: y, ez: z } = this;\n        // fast-paths for ZERO point OR Z=1\n        if (this.equals(I))\n            return { x: 0n, y: 1n };\n        const iz = invert(z, P);\n        // (Z * Z^-1) must be 1, otherwise bad math\n        if (M(z * iz) !== 1n)\n            err('invalid inverse');\n        // x = X*Z^-1; y = Y*Z^-1\n        return { x: M(x * iz), y: M(y * iz) };\n    }\n    toBytes() {\n        const { x, y } = this.assertValidity().toAffine();\n        const b = numTo32bLE(y);\n        // store sign in first LE byte\n        b[31] |= x & 1n ? 0x80 : 0;\n        return b;\n    }\n    toHex() {\n        return bytesToHex(this.toBytes());\n    } // encode to hex string\n    clearCofactor() {\n        return this.multiply(big(h), false);\n    }\n    isSmallOrder() {\n        return this.clearCofactor().is0();\n    }\n    isTorsionFree() {\n        // multiply by big number CURVE.n\n        let p = this.multiply(N / 2n, false).double(); // ensures the point is not \"bad\".\n        if (N % 2n)\n            p = p.add(this); // P^(N+1) // P*N == (P*(N/2))*2+P\n        return p.is0();\n    }\n    static fromHex(hex, zip215) {\n        return Point.fromBytes(toU8(hex), zip215);\n    }\n    get x() {\n        return this.toAffine().x;\n    }\n    get y() {\n        return this.toAffine().y;\n    }\n    toRawBytes() {\n        return this.toBytes();\n    }\n}\n/** Generator / base point */\nconst G = new Point(Gx, Gy, 1n, M(Gx * Gy));\n/** Identity / zero point */\nconst I = new Point(0n, 1n, 1n, 0n);\n// Static aliases\nPoint.BASE = G;\nPoint.ZERO = I;\nconst numTo32bLE = (num) => hexToBytes(padh(arange(num, 0n, B256), L2)).reverse();\nconst bytesToNumLE = (b) => big('0x' + bytesToHex(u8fr(abytes(b)).reverse()));\nconst pow2 = (x, power) => {\n    // pow2(x, 4) == x^(2^4)\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n};\n// prettier-ignore\nconst pow_2_252_3 = (x) => {\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n};\nconst RM1 = 0x2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0n; // √-1\n// for sqrt comp\n// prettier-ignore\nconst uvRatio = (u, v) => {\n    const v3 = M(v * v * v); // v³\n    const v7 = M(v3 * v3 * v); // v⁷\n    const pow = pow_2_252_3(u * v7).pow_p_5_8; // (uv⁷)^(p-5)/8\n    let x = M(u * v3 * pow); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = M(v * x * x); // vx²\n    const root1 = x; // First root candidate\n    const root2 = M(x * RM1); // Second root candidate; RM1 is √-1\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === M(-u); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === M(-u * RM1); // There is no valid root, vx² = -u√-1\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if ((M(x) & 1n) === 1n)\n        x = M(-x); // edIsNegative\n    return { isValid: useRoot1 || useRoot2, value: x };\n};\n// N == L, just weird naming\nconst modL_LE = (hash) => modN(bytesToNumLE(hash)); // modulo L; but little-endian\nconst sha512a = (...m) => etc.sha512Async(...m); // Async SHA512\nconst sha512s = (...m) => callHash('sha512Sync')(...m);\n// RFC8032 5.1.5\nconst hash2extK = (hashed) => {\n    // slice creates a copy, unlike subarray\n    const head = hashed.slice(0, L);\n    head[0] &= 248; // Clamp bits: 0b1111_1000\n    head[31] &= 127; // 0b0111_1111\n    head[31] |= 64; // 0b0100_0000\n    const prefix = hashed.slice(L, L2); // private key \"prefix\"\n    const scalar = modL_LE(head); // modular division over curve order\n    const point = G.multiply(scalar); // public key point\n    const pointBytes = point.toBytes(); // point serialized to Uint8Array\n    return { head, prefix, scalar, point, pointBytes };\n};\n// RFC8032 5.1.5; getPublicKey async, sync. Hash priv key and extract point.\nconst getExtendedPublicKeyAsync = (priv) => sha512a(toU8(priv, L)).then(hash2extK);\nconst getExtendedPublicKey = (priv) => hash2extK(sha512s(toU8(priv, L)));\n/** Creates 32-byte ed25519 public key from 32-byte private key. Async. */\nconst getPublicKeyAsync = (priv) => getExtendedPublicKeyAsync(priv).then((p) => p.pointBytes);\n/** Creates 32-byte ed25519 public key from 32-byte private key. To use, set `etc.sha512Sync` first. */\nconst getPublicKey = (priv) => getExtendedPublicKey(priv).pointBytes;\nconst hashFinishA = (res) => sha512a(res.hashable).then(res.finish);\nconst hashFinishS = (res) => res.finish(sha512s(res.hashable));\nconst _sign = (e, rBytes, msg) => {\n    // sign() shared code\n    const { pointBytes: P, scalar: s } = e;\n    const r = modL_LE(rBytes); // r was created outside, reduce it modulo L\n    const R = G.multiply(r).toBytes(); // R = [r]B\n    const hashable = concatBytes(R, P, msg); // dom2(F, C) || R || A || PH(M)\n    const finish = (hashed) => {\n        // k = SHA512(dom2(F, C) || R || A || PH(M))\n        const S = modN(r + modL_LE(hashed) * s); // S = (r + k * s) mod L; 0 <= s < l\n        return abytes(concatBytes(R, numTo32bLE(S)), L2); // 64-byte sig: 32b R.x + 32b LE(S)\n    };\n    return { hashable, finish };\n};\n/**\n * Signs message (NOT message hash) using private key. Async.\n * Follows RFC8032 5.1.6.\n */\nconst signAsync = async (msg, privKey) => {\n    const m = toU8(msg);\n    const e = await getExtendedPublicKeyAsync(privKey);\n    const rBytes = await sha512a(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinishA(_sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\n/**\n * Signs message (NOT message hash) using private key. To use, set `hashes.sha512` first.\n * Follows RFC8032 5.1.6.\n */\nconst sign = (msg, privKey) => {\n    const m = toU8(msg);\n    const e = getExtendedPublicKey(privKey);\n    const rBytes = sha512s(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinishS(_sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\nconst veriOpts = { zip215: true };\nconst _verify = (sig, msg, pub, opts = veriOpts) => {\n    sig = toU8(sig, L2); // Signature hex str/Bytes, must be 64 bytes\n    msg = toU8(msg); // Message hex str/Bytes\n    pub = toU8(pub, L);\n    const { zip215 } = opts; // switch between zip215 and rfc8032 verif\n    let A;\n    let R;\n    let s;\n    let SB;\n    let hashable = Uint8Array.of();\n    try {\n        A = Point.fromHex(pub, zip215); // public key A decoded\n        R = Point.fromHex(sig.slice(0, L), zip215); // 0 <= R < 2^256: ZIP215 R can be >= P\n        s = bytesToNumLE(sig.slice(L, L2)); // Decode second half as an integer S\n        SB = G.multiply(s, false); // in the range 0 <= s < L\n        hashable = concatBytes(R.toBytes(), A.toBytes(), msg); // dom2(F, C) || R || A || PH(M)\n    }\n    catch (error) { }\n    const finish = (hashed) => {\n        // k = SHA512(dom2(F, C) || R || A || PH(M))\n        if (SB == null)\n            return false; // false if try-catch catched an error\n        if (!zip215 && A.isSmallOrder())\n            return false; // false for SBS: Strongly Binding Signature\n        const k = modL_LE(hashed); // decode in little-endian, modulo L\n        const RkA = R.add(A.multiply(k, false)); // [8]R + [8][k]A'\n        return RkA.add(SB.negate()).clearCofactor().is0(); // [8][S]B = [8]R + [8][k]A'\n    };\n    return { hashable, finish };\n};\n/** Verifies signature on message and public key. Async. Follows RFC8032 5.1.7. */\nconst verifyAsync = async (s, m, p, opts = veriOpts) => hashFinishA(_verify(s, m, p, opts));\n/** Verifies signature on message and public key. To use, set `hashes.sha512` first. Follows RFC8032 5.1.7. */\nconst verify = (s, m, p, opts = veriOpts) => hashFinishS(_verify(s, m, p, opts));\n/** Math, hex, byte helpers. Not in `utils` because utils share API with noble-curves. */\nconst etc = {\n    sha512Async: async (...messages) => {\n        const s = subtle();\n        const m = concatBytes(...messages);\n        return u8n(await s.digest('SHA-512', m.buffer));\n    },\n    sha512Sync: undefined,\n    bytesToHex: bytesToHex,\n    hexToBytes: hexToBytes,\n    concatBytes: concatBytes,\n    mod: M,\n    invert: invert,\n    randomBytes: randomBytes,\n};\n/** ed25519-specific key utilities. */\nconst utils = {\n    getExtendedPublicKeyAsync: getExtendedPublicKeyAsync,\n    getExtendedPublicKey: getExtendedPublicKey,\n    randomPrivateKey: () => randomBytes(L),\n    precompute: (w = 8, p = G) => {\n        p.multiply(3n);\n        w;\n        return p;\n    }, // no-op\n};\n// ## Precomputes\n// --------------\nconst W = 8; // W is window size\nconst scalarBits = 256;\nconst pwindows = Math.ceil(scalarBits / W) + 1; // 33 for W=8\nconst pwindowSize = 2 ** (W - 1); // 128 for W=8\nconst precompute = () => {\n    const points = [];\n    let p = G;\n    let b = p;\n    for (let w = 0; w < pwindows; w++) {\n        b = p;\n        points.push(b);\n        for (let i = 1; i < pwindowSize; i++) {\n            b = b.add(p);\n            points.push(b);\n        } // i=1, bc we skip 0\n        p = b.double();\n    }\n    return points;\n};\nlet Gpows = undefined; // precomputes for base point G\n// const-time negate\nconst ctneg = (cnd, p) => {\n    const n = p.negate();\n    return cnd ? n : p;\n};\n/**\n * Precomputes give 12x faster getPublicKey(), 10x sign(), 2x verify() by\n * caching multiples of G (base point). Cache is stored in 32MB of RAM.\n * Any time `G.multiply` is done, precomputes are used.\n * Not used for getSharedSecret, which instead multiplies random pubkey `P.multiply`.\n *\n * w-ary non-adjacent form (wNAF) precomputation method is 10% slower than windowed method,\n * but takes 2x less RAM. RAM reduction is possible by utilizing `.subtract`.\n *\n * !! Precomputes can be disabled by commenting-out call of the wNAF() inside Point#multiply().\n */\nconst wNAF = (n) => {\n    const comp = Gpows || (Gpows = precompute());\n    let p = I;\n    let f = G; // f must be G, or could become I in the end\n    const pow_2_w = 2 ** W; // 256 for W=8\n    const maxNum = pow_2_w; // 256 for W=8\n    const mask = big(pow_2_w - 1); // 255 for W=8 == mask 0b11111111\n    const shiftBy = big(W); // 8 for W=8\n    for (let w = 0; w < pwindows; w++) {\n        let wbits = Number(n & mask); // extract W bits.\n        n >>= shiftBy; // shift number by W bits.\n        if (wbits > pwindowSize) {\n            wbits -= maxNum;\n            n += 1n;\n        } // split if bits > max: +224 => 256-32\n        const off = w * pwindowSize;\n        const offF = off; // offsets, evaluate both\n        const offP = off + Math.abs(wbits) - 1;\n        const isEven = w % 2 !== 0; // conditions, evaluate both\n        const isNeg = wbits < 0;\n        if (wbits === 0) {\n            // off == I: can't add it. Adding random offF instead.\n            f = f.add(ctneg(isEven, comp[offF])); // bits are 0: add garbage to fake point\n        }\n        else {\n            p = p.add(ctneg(isNeg, comp[offP])); // bits are 1: add to result point\n        }\n    }\n    return { p, f }; // return both real and fake points for JIT\n};\n// !! Remove the export to easily use in REPL / browser console\nexport { ed25519_CURVE as CURVE, etc, Point as ExtendedPoint, getPublicKey, getPublicKeyAsync, Point, sign, signAsync, utils, verify, verifyAsync, };\n"],
  "mappings": "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",
  "names": ["_a", "C", "G", "P"]
}
