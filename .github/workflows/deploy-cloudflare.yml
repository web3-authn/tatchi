name: deploy-cloudflare

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment (must match GitHub Environment name with secrets)"
        required: false
        default: "production"
  push:
    branches: [ main ]

jobs:
  build-sdk:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 9

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install deps (workspace)
        run: pnpm install --no-frozen-lockfile

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Add wasm target
        run: rustup target add wasm32-unknown-unknown

      - name: Install wasm-pack
        run: |
          curl -sSf https://rustwasm.github.io/wasm-pack/installer/init.sh | sh

      - name: Setup Bun (for worker bundling step in build scripts)
        uses: oven-sh/setup-bun@v2

      - name: Build SDK (sdk, production)
        run: pnpm build:sdk-prod

  publish-sdk-r2:
    runs-on: ubuntu-latest
    needs: build-sdk
    environment:
      name: production
    permissions:
      contents: read
      id-token: write   # for cosign keyless signing
    env:
      R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
      R2_BUCKET: ${{ secrets.R2_BUCKET }}
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 9

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install deps (workspace)
        run: pnpm install --no-frozen-lockfile

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Add wasm target
        run: rustup target add wasm32-unknown-unknown

      - name: Install wasm-pack
        run: |
          curl -sSf https://rustwasm.github.io/wasm-pack/installer/init.sh | sh

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Build SDK (sdk, production)
        run: pnpm build:sdk-prod

      - name: Validate R2 secrets are present
        run: |
          set -eu
          test -n "${R2_ENDPOINT:-}" || (echo "R2_ENDPOINT is not set" >&2; exit 1)
          test -n "${R2_BUCKET:-}" || (echo "R2_BUCKET is not set" >&2; exit 1)
          test -n "${AWS_ACCESS_KEY_ID:-}" || (echo "R2_ACCESS_KEY_ID is not set" >&2; exit 1)
          test -n "${AWS_SECRET_ACCESS_KEY:-}" || (echo "R2_SECRET_ACCESS_KEY is not set" >&2; exit 1)

      - name: Generate sha256 manifest (sorted)
        run: |
          cd sdk/dist
          find . -type f \
            ! -name 'manifest.json' \
            ! -name 'manifest.sig' \
            -exec sha256sum {} + | sort > manifest.sha256

      - name: Convert manifest to JSON
        run: |
          cd sdk/dist
          python3 - <<'PY'
          import json, pathlib
          entries = []
          for line in pathlib.Path('manifest.sha256').read_text().splitlines():
            parts = line.split(maxsplit=1)
            if len(parts) != 2: continue
            digest, path = parts
            entries.append({"path": path, "sha256": digest})
          pathlib.Path('manifest.json').write_text(json.dumps({"files": entries}, indent=2))
          PY

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.5.0

      - name: Sign manifest with cosign (keyless)
        env:
          COSIGN_EXPERIMENTAL: 'true'
        run: |
          cd sdk/dist
          cosign sign-blob --yes --output-signature manifest.sig manifest.json

      - name: Install AWS CLI (via pip)
        run: |
          python3 -m pip install --user awscli
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Publish to Cloudflare R2 (by commit SHA)
        env:
          PREFIX: releases/${{ github.sha }}
        run: |
          set -euxo pipefail
          test -n "$R2_ENDPOINT" && test -n "$R2_BUCKET"
          aws s3 sync sdk/dist s3://$R2_BUCKET/$PREFIX \
            --endpoint-url "$R2_ENDPOINT" --delete
          # Ensure correct MIME for wasm files
          for f in $(find sdk/dist -name "*.wasm" -type f); do
            key=${f#sdk/dist/}
            aws s3 cp "$f" s3://$R2_BUCKET/$PREFIX/"$key" \
              --endpoint-url "$R2_ENDPOINT" \
              --content-type application/wasm \
              --metadata-directive REPLACE
          done

      - name: Optionally publish under tag name when releasing
        if: startsWith(github.ref, 'refs/tags/')
        env:
          PREFIX: releases/${{ github.ref_name }}
        run: |
          set -euxo pipefail
          test -n "$R2_ENDPOINT" && test -n "$R2_BUCKET"
          aws s3 sync sdk/dist s3://$R2_BUCKET/$PREFIX \
            --endpoint-url "$R2_ENDPOINT" --delete
          for f in $(find sdk/dist -name "*.wasm" -type f); do
            key=${f#sdk/dist/}
            aws s3 cp "$f" s3://$R2_BUCKET/$PREFIX/"$key" \
              --endpoint-url "$R2_ENDPOINT" \
              --content-type application/wasm \
              --metadata-directive REPLACE
          done

  deploy-worker:
    runs-on: ubuntu-latest
    needs: build-sdk
    environment:
      name: production
    env:
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      RECOVER_EMAIL_RECIPIENT: ${{ vars.RECOVER_EMAIL_RECIPIENT }}
      # Optional: Threshold signing (2p FROST)
      THRESHOLD_ED25519_SHARE_MODE: ${{ vars.THRESHOLD_ED25519_SHARE_MODE }}
      UPSTASH_REDIS_REST_URL: ${{ vars.UPSTASH_REDIS_REST_URL }}
      THRESHOLD_ED25519_AUTH_PREFIX: ${{ vars.THRESHOLD_ED25519_AUTH_PREFIX }}
      THRESHOLD_ED25519_SESSION_PREFIX: ${{ vars.THRESHOLD_ED25519_SESSION_PREFIX }}
      THRESHOLD_ED25519_KEYSTORE_PREFIX: ${{ vars.THRESHOLD_ED25519_KEYSTORE_PREFIX }}
      THRESHOLD_ED25519_MASTER_SECRET_B64U: ${{ secrets.THRESHOLD_ED25519_MASTER_SECRET_B64U }}
      UPSTASH_REDIS_REST_TOKEN: ${{ secrets.UPSTASH_REDIS_REST_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 9

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Add wasm target
        run: rustup target add wasm32-unknown-unknown

      - name: Install wasm-pack
        run: |
          curl -sSf https://rustwasm.github.io/wasm-pack/installer/init.sh | sh

      - name: Setup Bun (for worker bundling step in build scripts)
        uses: oven-sh/setup-bun@v2

      - name: Install deps (workspace)
        run: pnpm install --no-frozen-lockfile

      - name: Build SDK (sdk, production) for Worker bundling
        run: pnpm build:sdk-prod

      - name: Deploy Cloudflare Worker (relay)
        run: |
          set -euo pipefail
          if [ -z "${RECOVER_EMAIL_RECIPIENT:-}" ]; then
            echo "RECOVER_EMAIL_RECIPIENT env var is not set in this GitHub Environment" >&2
            exit 1
          fi

          # Optional: set/update secrets for threshold signing + Upstash (persist across deploys).
          if [ -n "${THRESHOLD_ED25519_MASTER_SECRET_B64U:-}" ]; then
            printf '%s' "$THRESHOLD_ED25519_MASTER_SECRET_B64U" \
              | pnpm -C examples/relay-cloudflare-worker exec wrangler secret put THRESHOLD_ED25519_MASTER_SECRET_B64U
          fi
          if [ -n "${UPSTASH_REDIS_REST_TOKEN:-}" ]; then
            printf '%s' "$UPSTASH_REDIS_REST_TOKEN" \
              | pnpm -C examples/relay-cloudflare-worker exec wrangler secret put UPSTASH_REDIS_REST_TOKEN
          fi

          # Build worker vars (avoid setting empty strings).
          ARGS=(--var RECOVER_EMAIL_RECIPIENT="${RECOVER_EMAIL_RECIPIENT}")
          if [ -n "${THRESHOLD_ED25519_SHARE_MODE:-}" ]; then ARGS+=(--var THRESHOLD_ED25519_SHARE_MODE="${THRESHOLD_ED25519_SHARE_MODE}"); fi
          if [ -n "${UPSTASH_REDIS_REST_URL:-}" ]; then ARGS+=(--var UPSTASH_REDIS_REST_URL="${UPSTASH_REDIS_REST_URL}"); fi
          if [ -n "${THRESHOLD_ED25519_AUTH_PREFIX:-}" ]; then ARGS+=(--var THRESHOLD_ED25519_AUTH_PREFIX="${THRESHOLD_ED25519_AUTH_PREFIX}"); fi
          if [ -n "${THRESHOLD_ED25519_SESSION_PREFIX:-}" ]; then ARGS+=(--var THRESHOLD_ED25519_SESSION_PREFIX="${THRESHOLD_ED25519_SESSION_PREFIX}"); fi
          if [ -n "${THRESHOLD_ED25519_KEYSTORE_PREFIX:-}" ]; then ARGS+=(--var THRESHOLD_ED25519_KEYSTORE_PREFIX="${THRESHOLD_ED25519_KEYSTORE_PREFIX}"); fi

          pnpm -C examples/relay-cloudflare-worker exec wrangler deploy "${ARGS[@]}"

      - name: Configure Email Routing for reset@web3authn.org
        env:
          CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CF_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          set -euo pipefail
          if [ -z "${CF_ZONE_ID:-}" ]; then
            echo "CLOUDFLARE_ZONE_ID / CF_ZONE_ID not set; skipping email routing configuration" >&2
            exit 0
          fi
          if [ -z "${RECOVER_EMAIL_RECIPIENT:-}" ]; then
            echo "RECOVER_EMAIL_RECIPIENT env var is not set in this GitHub Environment" >&2
            exit 1
          fi
          API="https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/email/routing/rules"
          echo "Creating Email Routing rule for ${RECOVER_EMAIL_RECIPIENT} → w3a-relay"
          # NOTE: Payload schema may need adjustment to match the latest
          # Cloudflare Email Routing API. See Cloudflare docs for details.
          curl -sS -X POST "$API" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data @- << JSON
          {
            "enabled": true,
            "name": "${RECOVER_EMAIL_RECIPIENT} to w3a-relay",
            "matchers": [
              {
                "type": "literal",
                "field": "to",
                "value": "${RECOVER_EMAIL_RECIPIENT}"
              }
            ],
            "actions": [
              {
                "type": "worker",
                "value": ["w3a-relay"]
              }
            ]
          }
          JSON

  deploy-pages:
    runs-on: ubuntu-latest
    needs: [build-sdk, publish-sdk-r2]
    environment:
      name: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 9

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Add wasm target
        run: rustup target add wasm32-unknown-unknown

      - name: Install wasm-pack
        run: |
          curl -sSf https://rustwasm.github.io/wasm-pack/installer/init.sh | sh

      - name: Setup Bun (for worker bundling step in build scripts)
        uses: oven-sh/setup-bun@v2

      - name: Install deps (workspace)
        run: pnpm install --no-frozen-lockfile

      - name: Build SDK (sdk, production) for Vite builds
        run: pnpm build:sdk-prod

      - name: Debug - print VITE_* env seen by build
        run: |
          echo "VITE_WALLET_ORIGIN=${{ vars.VITE_WALLET_ORIGIN }}"
          echo "VITE_WALLET_SERVICE_PATH=${{ vars.VITE_WALLET_SERVICE_PATH }}"
          echo "VITE_RP_ID_BASE=${{ vars.VITE_RP_ID_BASE }}"
          echo "VITE_RELAYER_URL=${{ vars.VITE_RELAYER_URL }}"
          echo "VITE_RELAYER_ACCOUNT_ID=${{ vars.VITE_RELAYER_ACCOUNT_ID }}"
          echo "VITE_NEAR_NETWORK=${{ vars.VITE_NEAR_NETWORK }}"
          echo "VITE_NEAR_RPC_URL=${{ vars.VITE_NEAR_RPC_URL }}"
          echo "VITE_NEAR_EXPLORER=${{ vars.VITE_NEAR_EXPLORER }}"
          echo "VITE_SDK_BASE_PATH=${{ vars.VITE_SDK_BASE_PATH }}"
          echo "VITE_WEBAUTHN_CONTRACT_ID=${{ vars.VITE_WEBAUTHN_CONTRACT_ID }}"

      - name: Build site with VitePress
        env:
          VITE_RELAYER_URL: ${{ vars.VITE_RELAYER_URL }}
          VITE_RELAYER_ACCOUNT_ID: ${{ vars.VITE_RELAYER_ACCOUNT_ID }}
          VITE_WEBAUTHN_CONTRACT_ID: ${{ vars.VITE_WEBAUTHN_CONTRACT_ID }}
          VITE_NEAR_NETWORK: ${{ vars.VITE_NEAR_NETWORK }}
          VITE_NEAR_RPC_URL: ${{ vars.VITE_NEAR_RPC_URL }}
          VITE_NEAR_EXPLORER: ${{ vars.VITE_NEAR_EXPLORER }}
          VITE_WALLET_ORIGIN: ${{ vars.VITE_WALLET_ORIGIN }}
          VITE_WALLET_SERVICE_PATH: ${{ vars.VITE_WALLET_SERVICE_PATH }}
          VITE_RP_ID_BASE: ${{ vars.VITE_RP_ID_BASE }}
          VITE_SDK_BASE_PATH: ${{ vars.VITE_SDK_BASE_PATH }}
        run: |
          pnpm docs:build

      - name: Debug – print built _headers (VitePress)
        run: |
          echo "--- examples/tatchi-docs/dist/docs/_headers (if present) ---"
          if [ -f examples/tatchi-docs/dist/docs/_headers ]; then
            cat examples/tatchi-docs/dist/docs/_headers
          else
            echo "(no _headers emitted)"
          fi

      - name: Copy SDK runtime assets into VitePress dist
        run: |
          # Serve SDK bundles under /sdk for uniform layout
          mkdir -p examples/tatchi-docs/dist/docs/sdk examples/tatchi-docs/dist/docs/sdk/workers
          cp -R sdk/dist/esm/sdk/* examples/tatchi-docs/dist/docs/sdk/ || true
          cp -R sdk/dist/workers/* examples/tatchi-docs/dist/docs/sdk/workers/ || true

      - name: Install Wrangler
        run: pnpm add -g wrangler@4

      - name: Debug - grep built dist for wallet origin (VitePress)
        run: |
          echo "Occurrences of wallet origin in built files (if any):"
          rg -n "wallet\\.tatchi\\.xyz|wallet\\.example\\.localhost" examples/tatchi-docs/dist/docs || true
          if rg -n "wallet\\.example\\.localhost" examples/tatchi-docs/dist/docs; then
            echo "ERROR: Built assets still reference wallet.example.localhost" >&2
            exit 1
          fi

      - name: Deploy VitePress site to Cloudflare Pages (primary site)
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          wrangler pages deploy examples/tatchi-docs/dist/docs --project-name "${{ secrets.CF_PAGES_PROJECT_VITE }}"

  deploy-wallet:
    runs-on: ubuntu-latest
    needs: build-sdk
    environment:
      name: production
    env:
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CF_PAGES_PROJECT_WALLET: ${{ secrets.CF_PAGES_PROJECT_WALLET }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 9

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Add wasm target
        run: rustup target add wasm32-unknown-unknown

      - name: Install wasm-pack
        run: |
          curl -sSf https://rustwasm.github.io/wasm-pack/installer/init.sh | sh

      - name: Setup Bun (for worker bundling step in build scripts)
        uses: oven-sh/setup-bun@v2

      - name: Install deps (workspace)
        run: pnpm install --no-frozen-lockfile

      - name: Build SDK (sdk, production)
        run: pnpm build:sdk-prod

      - name: Build wallet host example (if present)
        if: ${{ hashFiles('examples/vite/package.json') != '' }}
        env:
          VITE_WALLET_ORIGIN: ${{ vars.VITE_WALLET_ORIGIN }}
          VITE_WALLET_SERVICE_PATH: ${{ vars.VITE_WALLET_SERVICE_PATH }}
          VITE_SDK_BASE_PATH: ${{ vars.VITE_SDK_BASE_PATH }}
          VITE_RP_ID_BASE: ${{ vars.VITE_RP_ID_BASE }}
          VITE_RELAYER_URL: ${{ vars.VITE_RELAYER_URL }}
          VITE_RELAYER_ACCOUNT_ID: ${{ vars.VITE_RELAYER_ACCOUNT_ID }}
          VITE_NEAR_NETWORK: ${{ vars.VITE_NEAR_NETWORK }}
          VITE_NEAR_RPC_URL: ${{ vars.VITE_NEAR_RPC_URL }}
          VITE_NEAR_EXPLORER: ${{ vars.VITE_NEAR_EXPLORER }}
          VITE_WEBAUTHN_CONTRACT_ID: ${{ vars.VITE_WEBAUTHN_CONTRACT_ID }}
        run: pnpm -C examples/vite build

      - name: Debug – print built _headers (wallet)
        if: ${{ hashFiles('examples/vite/package.json') != '' }}
        run: |
          echo "--- examples/vite/dist/_headers (if present) ---"
          if [ -f examples/vite/dist/_headers ]; then
            cat examples/vite/dist/_headers
          else
            echo "(no _headers emitted)"
          fi

      - name: Copy SDK assets into Pages output (example)
        if: ${{ hashFiles('examples/vite/package.json') != '' }}
        run: |
          mkdir -p examples/vite/dist/sdk examples/vite/dist/sdk/workers
          rsync -av --delete sdk/dist/esm/sdk/ examples/vite/dist/sdk/
          if [ -d sdk/dist/workers ]; then
            rsync -av --delete sdk/dist/workers/ examples/vite/dist/sdk/workers/
          fi

      - name: Fail if example missing
        if: ${{ hashFiles('examples/vite/package.json') == '' }}
        run: |
          echo "::error::Missing wallet host example at examples/vite" >&2
          echo "Create it (docs cover how) or re-enable the CI fallback." >&2
          exit 1

      - name: Install Wrangler
        run: pnpm add -g wrangler@4

      - name: Deploy wallet static site to Cloudflare Pages
        run: |
          wrangler pages deploy examples/vite/dist --project-name "$CF_PAGES_PROJECT_WALLET"

  # publish-npm:
  #   name: Publish SDK to npm
  #   runs-on: ubuntu-latest
  #   # Only publish after all production deploy jobs succeed, and only on tag pushes
  #   needs: [deploy-worker, deploy-pages, deploy-wallet]
  #   if: startsWith(github.ref, 'refs/tags/')
  #   permissions:
  #     contents: read
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4
  #       with:
  #         fetch-depth: 0

  #     - name: Setup pnpm
  #       uses: pnpm/action-setup@v3
  #       with:
  #         version: 9

  #     - name: Setup Node (npm registry)
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: '20'
  #         cache: 'pnpm'
  #         registry-url: 'https://registry.npmjs.org'

  #     - name: Install Rust toolchain
  #       uses: dtolnay/rust-toolchain@stable

  #     - name: Add wasm target
  #       run: rustup target add wasm32-unknown-unknown

  #     - name: Install wasm-pack
  #       run: |
  #         curl -sSf https://rustwasm.github.io/wasm-pack/installer/init.sh | sh

  #     - name: Setup Bun (for worker bundling step in build scripts)
  #       uses: oven-sh/setup-bun@v2

  #     - name: Install deps (workspace)
  #       run: pnpm install --no-frozen-lockfile

  #     - name: Build SDK (sdk)
  #       run: pnpm -C sdk build

  #     - name: Skip if version already published
  #       id: check_published
  #       working-directory: sdk
  #       env:
  #         NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
  #       run: |
  #         set -euo pipefail
  #         NAME=$(node -p "require('./package.json').name")
  #         VERSION=$(node -p "require('./package.json').version")
  #         echo "Checking if $NAME@$VERSION exists on npm..."
  #         if npm view "$NAME@$VERSION" version >/dev/null 2>&1; then
  #           echo "already=true" >> $GITHUB_OUTPUT
  #           echo "Version already published; skipping." >&2
  #         else
  #           echo "already=false" >> $GITHUB_OUTPUT
  #           echo "Not published yet; will publish." >&2
  #         fi

  #     - name: Publish @tatchi/* packages to npm
  #       if: steps.check_published.outputs.already == 'false'
  #       working-directory: sdk
  #       env:
  #         NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
  #       run: |
  #         npm publish --access public
