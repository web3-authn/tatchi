name: deploy-relay-staging

on:
  push:
    branches: [ dev ]
  workflow_dispatch: {}

jobs:
  deploy-relay-staging:
    runs-on: ubuntu-latest
    environment:
      name: staging
    env:
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      RECOVER_EMAIL_RECIPIENT: ${{ vars.RECOVER_EMAIL_RECIPIENT }}
      WORKER_NAME: w3a-relay-staging
      # Optional: Threshold signing (2p FROST; derived relayer share)
      THRESHOLD_ED25519_SHARE_MODE: derive
      THRESHOLD_ED25519_MASTER_SECRET_B64U: ${{ secrets.THRESHOLD_ED25519_MASTER_SECRET_B64U }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 9

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Add wasm target
        run: rustup target add wasm32-unknown-unknown

      - name: Install wasm-pack
        run: |
          curl -sSf https://rustwasm.github.io/wasm-pack/installer/init.sh | sh

      - name: Setup Bun (for worker bundling step in build scripts)
        uses: oven-sh/setup-bun@v2

      - name: Install deps (workspace)
        run: pnpm install --no-frozen-lockfile

      - name: Build SDK (sdk, production) for Worker bundling
        run: pnpm build:sdk-prod

      - name: Deploy Cloudflare Worker (relay)
        run: |
          set -euo pipefail
          if [ -z "${RECOVER_EMAIL_RECIPIENT:-}" ]; then
            echo "RECOVER_EMAIL_RECIPIENT env var is not set in this GitHub Environment" >&2
            exit 1
          fi

          # Optional: set/update secrets for threshold signing (persist across deploys).
          if [ -n "${THRESHOLD_ED25519_MASTER_SECRET_B64U:-}" ]; then
            printf '%s' "$THRESHOLD_ED25519_MASTER_SECRET_B64U" \
              | pnpm -C examples/relay-cloudflare-worker exec wrangler secret put THRESHOLD_ED25519_MASTER_SECRET_B64U --name "$WORKER_NAME"
          fi

          # Build worker vars (avoid setting empty strings).
          ARGS=(--var RECOVER_EMAIL_RECIPIENT="${RECOVER_EMAIL_RECIPIENT}")
          ARGS+=(--var THRESHOLD_ED25519_SHARE_MODE="${THRESHOLD_ED25519_SHARE_MODE}")

          pnpm -C examples/relay-cloudflare-worker exec wrangler deploy --config wrangler.toml --env staging "${ARGS[@]}"

      - name: Configure Email Routing for RECOVER_EMAIL_RECIPIENT
        env:
          CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CF_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          set -euo pipefail
          if [ -z "${CF_ZONE_ID:-}" ]; then
            echo "CLOUDFLARE_ZONE_ID / CF_ZONE_ID not set; skipping email routing configuration" >&2
            exit 0
          fi
          if [ -z "${RECOVER_EMAIL_RECIPIENT:-}" ]; then
            echo "RECOVER_EMAIL_RECIPIENT env var is not set in this GitHub Environment" >&2
            exit 1
          fi
          if [ -z "${WORKER_NAME:-}" ]; then
            echo "WORKER_NAME env var is not set in this GitHub Environment" >&2
            exit 1
          fi
          if ! command -v jq >/dev/null 2>&1; then
            echo "jq is required on the runner to manage Cloudflare Email Routing rules" >&2
            exit 1
          fi

          API_BASE="https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/email/routing/rules"
          auth=(-H "Authorization: Bearer $CF_API_TOKEN" -H "Content-Type: application/json")

          echo "Ensuring Email Routing rule for ${RECOVER_EMAIL_RECIPIENT} â†’ ${WORKER_NAME}"

          existing="$(curl -sS -X GET "$API_BASE" "${auth[@]}")"
          echo "$existing" | jq -e '.success == true' >/dev/null || { echo "$existing"; exit 1; }

          # Delete any existing rules for this recipient.
          rule_ids="$(echo "$existing" | jq -r --arg r "$RECOVER_EMAIL_RECIPIENT" '.result[]? | select(.matchers[]? | (.value? == $r)) | .id')"
          if [ -n "${rule_ids:-}" ]; then
            echo "$rule_ids" | while read -r id; do
              [ -z "${id:-}" ] && continue
              echo "Deleting existing Email Routing rule id=$id for ${RECOVER_EMAIL_RECIPIENT}"
              del="$(curl -sS -X DELETE "$API_BASE/$id" "${auth[@]}")"
              echo "$del" | jq -e '.success == true' >/dev/null || { echo "$del"; exit 1; }
            done
          fi

          create="$(curl -sS -X POST "$API_BASE" "${auth[@]}" --data @- << JSON
          {
            "enabled": true,
            "name": "${RECOVER_EMAIL_RECIPIENT} to ${WORKER_NAME}",
            "matchers": [
              {
                "type": "literal",
                "field": "to",
                "value": "${RECOVER_EMAIL_RECIPIENT}"
              }
            ],
            "actions": [
              {
                "type": "worker",
                "value": ["${WORKER_NAME}"]
              }
            ]
          }
          JSON
          )"
          echo "$create" | jq -e '.success == true' >/dev/null || { echo "$create"; exit 1; }
