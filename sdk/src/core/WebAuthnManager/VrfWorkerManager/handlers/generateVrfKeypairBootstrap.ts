import type { VRFInputData } from '../../../types/vrf-worker';
import { validateVRFChallenge, type VRFChallenge } from '../../../types/vrf-worker';
import type { VRFWorkerMessage, WasmGenerateVrfKeypairBootstrapRequest } from '../../../types/vrf-worker';
import type { VrfWorkerManagerHandlerContext } from './types';

/**
 * Registration bootstrap: generate a fresh random VRF keypair in the VRF worker and (optionally)
 * generate a VRF challenge from it.
 *
 * This solves the "chicken-and-egg" problem during registration where you need a VRF challenge
 * before you have PRF outputs to encrypt the VRF keypair. The generated VRF keypair lives in
 * VRF worker memory until it is later encrypted with PRF output.
 */
export async function generateVrfKeypairBootstrap(
  ctx: VrfWorkerManagerHandlerContext,
  args: {
    vrfInputData: VRFInputData;
    saveInMemory: boolean;
    sessionId?: string;
  }
): Promise<{
  vrfPublicKey: string;
  vrfChallenge: VRFChallenge;
}> {
  await ctx.ensureWorkerReady();
  try {
    const message: VRFWorkerMessage<WasmGenerateVrfKeypairBootstrapRequest> = {
      type: 'GENERATE_VRF_KEYPAIR_BOOTSTRAP',
      id: ctx.generateMessageId(),
	      payload: {
	        // Include VRF input data if provided for challenge generation
	        sessionId: args.sessionId,
	        vrfInputData: args.vrfInputData
	          ? {
	              userId: args.vrfInputData.userId,
	              rpId: args.vrfInputData.rpId,
	              blockHeight: String(args.vrfInputData.blockHeight),
	              blockHash: args.vrfInputData.blockHash,
	              intentDigest: args.vrfInputData.intentDigest,
	            }
	          : undefined,
	      },
	    };

    const response = await ctx.sendMessage(message);

    if (!response.success || !response.data) {
      throw new Error(`VRF bootstrap keypair generation failed: ${response.error}`);
    }
    const data = response.data as { vrf_challenge_data?: VRFChallenge; vrfPublicKey?: string };
    const challengeData = data.vrf_challenge_data as VRFChallenge | undefined;
    if (!challengeData) {
      throw new Error('VRF challenge data failed to be generated');
    }
    const vrfPublicKey = data.vrfPublicKey || challengeData.vrfPublicKey;
    if (!vrfPublicKey) {
      throw new Error('VRF public key missing in bootstrap response');
    }
    if (args.vrfInputData && args.saveInMemory) {
      // Track the account ID for this VRF session if saving in memory
      ctx.setCurrentVrfAccountId(args.vrfInputData.userId);
    }

    // TODO: strong types generated by Rust wasm-bindgen
    return {
      vrfPublicKey,
      vrfChallenge: validateVRFChallenge({
        vrfInput: challengeData.vrfInput,
        vrfOutput: challengeData.vrfOutput,
        vrfProof: challengeData.vrfProof,
        vrfPublicKey: challengeData.vrfPublicKey,
        userId: challengeData.userId,
        rpId: challengeData.rpId,
        blockHeight: challengeData.blockHeight,
        blockHash: challengeData.blockHash,
        ...(challengeData.intentDigest ? { intentDigest: challengeData.intentDigest } : {}),
      })
    }

  } catch (error: any) {
    console.error('VRF Manager: Bootstrap VRF keypair generation failed:', error);
    throw new Error(`Failed to generate bootstrap VRF keypair: ${error.message}`);
  }
}
